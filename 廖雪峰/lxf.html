<!DOCTYPE html>
<html xmlns:itranswarp="http://www.itranswarp.com/" xmlns:wb="http://open.weibo.com/wb">
<!--

-->
<head></head>
<body>


</body>
<br><br><br>Python教程<br>============
这是小白的Python新手教程，具有如下特点：
中文，免费，零起点，完整示例，基于最新的Python 3版本。
Python是一种计算机程序设计语言。你可能已经听说过很多种流行的编程语言，比如非常难学的C语言，非常流行的Java语言，适合初学者的Basic语言，适合网页编程的JavaScript语言等等。
那Python是一种什么语言？
首先，我们普及一下编程语言的基础知识。用任何编程语言来开发程序，都是为了让计算机干活，比如下载一个MP3，编写一个文档等等，而计算机干活的CPU只认识机器指令，所以，尽管不同的编程语言差异极大，最后都得“翻译”成CPU可以执行的机器指令。而不同的编程语言，干同一个活，编写的代码量，差距也很大。
比如，完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行。
所以Python是一种相当高级的语言。
你也许会问，代码少还不好？代码少的代价是运行速度慢，C程序运行1秒钟，Java程序可能需要2秒，而Python程序可能就需要10秒。
那是不是越低级的程序越难学，越高级的程序越简单？表面上来说，是的，但是，在非常高的抽象计算中，高级的Python程序设计也是非常难学的，所以，高级程序语言不等于简单。
但是，对于初学者和完成普通任务，Python语言是非常简单易用的。连Google都在大规模使用Python，你就不用担心学了会没用。
用Python可以做什么？可以做日常任务，比如自动备份你的MP3；可以做网站，很多著名的网站包括YouTube就是Python写的；可以做网络游戏的后台，很多在线游戏的后台都是Python开发的。总之就是能干很多很多事啦。
Python当然也有不能干的事情，比如写操作系统，这个只能用C语言写；写手机应用，只能用Swift/Objective-C（针对iPhone）和Java（针对Android）；写3D游戏，最好用C或C++。
如果你是小白用户，满足以下条件：


不要再犹豫了，这个教程就是为你准备的！
准备好了吗？
None
关于作者
None
None
<br><br><br>Python简介<br>============
Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。
现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。这是最近10年最常用的10种编程语言的变化图：
None
总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。
当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。
Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。
除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。
许多大型网站就是用Python开发的，例如YouTube、
龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。
总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。
那Python适合开发哪些类型的应用呢？
首选是网络应用，包括网站、后台服务等等；
其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等；
另外就是把其他语言开发的程序再包装起来，方便使用。
最后说说Python的缺点。
任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？
第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。
但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。
None
第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。
这个缺点仅限于你要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。
再说了，现在如火如荼的开源运动和互联网自由开放的精神是一致的，互联网上有无数非常优秀的像Linux一样的开源代码，我们千万不要高估自己写的代码真的有非常大的“商业价值”。那些大公司的代码不愿意开放的更重要的原因是代码写得太烂了，一旦开源，就没人敢用他们的产品了。
None
当然，Python还有其他若干小缺点，请自行忽略，就不一一列举了。
<br><br><br>安装Python<br>============
因为Python是跨平台的，它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写Python程序，放到Linux上也是能够运行的。
要开始学习Python编程，首先就得把Python安装到你的电脑里。安装后，你会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。
安装Python 3.5
目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的。由于3.x版越来越普及，我们的教程将以最新的Python 3.5版本为基础。请确保你的电脑上安装的Python版本是最新的3.5.x，这样，你才能无痛学习这个教程。
在Mac上安装Python
如果你正在使用Mac，系统是OS X 10.8~10.10，那么系统自带的Python版本是2.7。要安装最新的Python 3.5，有两个方法：
方法一：从Python官网下载Python 3.5的
方法二：如果安装了Homebrew，直接通过命令
在Linux上安装Python
如果你正在使用Linux，那我可以假定你有Linux系统管理经验，自行安装Python 3应该没有问题，否则，请换回Windows系统。
对于大量的目前仍在使用Windows的同学，如果短期内没有打算换Mac，就可以继续阅读以下内容。
在Windows上安装Python
首先，根据你的Windows版本（64位还是32位）从Python的官方网站下载Python 3.5对应的
None
特别要注意勾上
视频演示：


运行Python
安装成功后，打开命令提示符窗口，敲入python后，会出现两种情况：
情况一：
None
看到上面的画面，就说明Python安装成功！
你看到提示符
情况二：得到一个错误：
None
None
这是因为Windows会根据一个
如果你不知道怎么修改环境变量，建议把Python安装程序重新运行一遍，务必记得勾上
视频演示：


小结
学会如何把Python安装到计算机中，并且熟练打开和退出Python交互式环境。
在Windows上运行Python时，请先启动命令行，然后运行
在Mac和Linux上运行Python时，请打开终端，然后运行
<br><br><br>Python解释器<br>============
当我们编写Python代码时，我们得到的是一个包含Python代码的以
由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。
CPython
当我们从
CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。
IPython
IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。
CPython用
PyPy
PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用
绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解
Jython
Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。
IronPython
IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。
小结
Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。
本教程的所有代码只确保在CPython 3.5版本下运行。请务必在本地安装CPython（也就是从Python官方网站下载的安装程序）。
<br><br><br>第一个Python程序<br>============
现在，了解了如何启动和退出Python的交互式环境，我们就可以正式开始编写Python代码了。
在写代码之前，请千万不要用“复制”-“粘贴”把代码从页面粘贴到你自己的电脑上。写程序也讲究一个感觉，你需要一个字母一个字母地把代码自己敲进去，在敲代码的过程中，初学者经常会敲错代码，所以，你需要仔细地检查、对照，才能以最快的速度掌握如何写程序。
None
在交互式环境的提示符
None
很简单吧，任何有效的数学计算都可以算出来。
如果要让Python打印出指定的文字，可以用
None
这种用单引号或者双引号括起来的文本在程序中叫字符串，今后我们还会经常遇到。
最后，用
视频演示：


命令行模式和Python交互模式
请注意区分命令行模式和Python交互模式。
看到类似
None
在命令行模式下，可以执行
看到
None
在Python交互式环境下，只能输入Python代码并立刻执行。
此外，在命令行模式运行
例如，在Python交互式环境下，输入：
None
直接可以看到结果
但是，写一个
None
然后在命令行模式下执行：
None
发现什么输出都没有。
这是正常的。想要输出结果，必须自己用
None
再执行，就可以看到结果：
None
小结
在Python交互式命令行下，可以直接输入代码，然后执行，并立刻得到结果。
<br><br><br>使用文本编辑器<br>============
在Python的交互式命令行写程序，好处是一下就能得到结果，坏处是没法保存，下次还想运行的时候，还得再敲一遍。
所以，实际开发的时候，我们总是使用一个文本编辑器来写代码，写完了，保存为一个文件，这样，程序就可以反复运行了。
现在，我们就把上次的
那么问题来了：文本编辑器到底哪家强？
推荐两款文本编辑器：
一个是
None
一个是
None
请注意，用哪个都行，但是
安装好文本编辑器后，输入以下代码：
None
注意
None
也可以保存为别的名字，比如
如果当前目录下没有
None
报错的意思就是，无法打开
视频演示：


直接运行py文件
有同学问，能不能像.exe文件那样直接运行
None
然后，通过命令给
None
就可以直接运行
None
小结
用文本编辑器写Python程序，然后保存为后缀为
Python的交互模式和直接运行
直接输入
直接运行
用Python开发程序，完全可以一边在文本编辑器里写代码，一边开一个交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27'的超大显示器！
参考源码
None
<br><br><br>Python代码运行助手<br>============
Python代码运行助手可以让你在线输入Python代码，然后通过本机运行的一个Python脚本来执行代码。原理如下：


None


None
下载
点击右键，目标另存为：
备用下载地址：
运行
在存放
None
如果看到
None
试试效果
需要支持HTML5的浏览器：



# 测试代码:
----
print('Hello, world')

<br><br><br>输入和输出<br>============
输出
用
None
None
None
None
None
None
None
因此，我们可以把计算
None
注意，对于
输入
现在，你已经可以用
None
当你输入
输入完成后，不会有任何提示，Python交互式命令行又回到
None
None
设正方形的边长为
若a=2，则面积为a x a = 2 x 2 = 4；
若a=3.5，则面积为a x a = 3.5 x 3.5 = 12.25。
在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，
要打印出
None
有了输入和输出，我们就可以把上次打印
None
运行上面的程序，第一行代码会让用户输入任意字符作为自己的名字，然后存入
None
但是程序运行的时候，没有任何提示信息告诉用户：“嘿，赶紧输入你的名字”，这样显得很不友好。幸好，
None
再次运行这个程序，你会发现，程序一运行，会首先打印出
None
每次运行该程序，根据用户输入的不同，输出结果也会不同。
在命令行下，输入和输出就是这么简单。
小结
任何计算机程序都是为了执行一个特定的任务，有了输入，用户才能告诉计算机程序所需的信息，有了输出，程序运行后才能告诉用户任务的结果。
输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。
None
练习
请利用

# -*- coding: utf-8 -*-
----
print(???)

参考源码
None
<br><br><br>Python基础<br>============
Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。
Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：
None
以
缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用
缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。
缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。
最后，请务必注意，Python程序是
小结
Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。
在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。
<br><br><br>数据类型和变量<br>============
数据类型
计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：
整数
Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：
计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用
浮点数
浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10
整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。
字符串
字符串是以单引号
如果字符串内部既包含
None
表示的字符串内容是：
None
转义字符
None
如果字符串里面有很多字符都需要转义，就需要加很多
None
如果字符串内部有很多换行，用
None
上面是在交互式命令行内输入，注意在输入多行内容时，提示符由
None
多行字符串
布尔值
布尔值和布尔代数的表示完全一致，一个布尔值只有
None
布尔值可以用
None
None
None
None
None
None
布尔值经常用在条件判断中，比如：
None
空值
空值是Python里一个特殊的值，用
此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。
变量
变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。
变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和
None
变量
None
变量
None
变量
在Python中，等号
None
这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：
None
和静态语言相比，动态语言更灵活，就是这个原因。
请不要把赋值语句的等号等同于数学的等号。比如下面的代码：
None
如果从数学上理解
最后，理解变量在计算机内存中的表示也非常重要。当我们写：
None
时，Python解释器干了两件事情：


也可以把一个变量
None
最后一行打印出变量
执行
None
执行
None
执行
None
所以，最后打印变量
常量
所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：
None
但事实上
最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是
None
None
None
还有一种除法是
None
你没有看错，整数的地板除
因为
None
无论整数做
练习
请打印出以下变量的值：

n = 123
f = 456.789
s1 = 'Hello, world'
s2 = 'Hello, \'Adam\''
s3 = r'Hello, "Bart"'
s4 = r'''Hello,
Lisa!'''

小结
Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。
注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在
Python的浮点数也没有大小限制，但是超出一定范围就直接表示为
<br><br><br>字符串和编码<br>============
字符编码
我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。
因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是
由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为
但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了
你可以想得到的是，全世界有上百种语言，日本把日文编到
None
因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。
Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。
现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。
字母
字符
汉字
你可以猜测，如果把ASCII编码的
新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。
所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的


从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。
搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：
在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。
用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：
None
浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：
None
所以你看到很多网页的源码上会有类似
Python的字符串
搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。
在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：
None
对于单个字符的编码，Python提供了
None
如果知道字符的整数编码，还可以用十六进制这么写
None
两种写法完全是等价的。
由于Python的字符串类型是
Python对
None
要注意区分
以Unicode表示的
None
纯英文的
在
反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是
None
要计算
None
None
None
可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。
在操作字符串时，我们经常遇到
由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
None
第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；
第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。
申明了UTF-8编码并不意味着你的
None
如果
None
格式化
最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似
None
在Python中，采用的格式化方式和C语言是一致的，用
None
你可能猜到了，
常见的占位符有：


其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：
None
如果你不太确定应该用什么，
None
有些时候，字符串里面的
None
练习
小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出

# -*- coding: utf-8 -*-

s1 = 72
s2 = 85
----
r = ???
print('???' % r)

小结
Python 3的字符串使用Unicode，直接支持多语言。
str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：
None
但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。
格式化字符串的时候，可以用Python的交互式命令行测试，方便快捷。
参考源码
None
<br><br><br>使用list和tuple<br>============
list
Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。
比如，列出班里所有同学的名字，就可以用一个list表示：
None
变量
None
用索引来访问list中每一个位置的元素，记得索引是从
None
当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是
如果要取最后一个元素，除了计算索引位置外，还可以用
None
以此类推，可以获取倒数第2个、倒数第3个：
None
当然，倒数第4个就越界了。
list是一个可变的有序表，所以，可以往list中追加元素到末尾：
None
也可以把元素插入到指定的位置，比如索引号为
None
要删除list末尾的元素，用
None
要删除指定位置的元素，用
None
要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
None
list里面的元素的数据类型也可以不同，比如：
None
list元素也可以是另一个list，比如：
None
要注意
None
要拿到
如果一个list中一个元素也没有，就是一个空的list，它的长度为0：
None
tuple
另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：
None
现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用
不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。
tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：
None
如果要定义一个空的tuple，可以写成
None
但是，要定义一个只有1个元素的tuple，如果你这么定义：
None
定义的不是tuple，是
所以，只有1个元素的tuple定义时必须加一个逗号
None
Python在显示只有1个元素的tuple时，也会加一个逗号
最后来看一个“可变的”tuple：
None
这个tuple定义的时候有3个元素，分别是
别急，我们先看看定义的时候tuple包含的3个元素：
None
当我们把list的元素
None
表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向
理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。
练习
请用索引取出下面list的指定元素：

# -*- coding: utf-8 -*-

L = [
    ['Apple', 'Google', 'Microsoft'],
    ['Java', 'Python', 'Ruby', 'PHP'],
    ['Adam', 'Bart', 'Lisa']
]
----
# 打印Apple:
print(?)
# 打印Python:
print(?)
# 打印Lisa:
print(?)

小结
list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。
参考源码
None
None
<br><br><br>条件判断<br>============
条件判断
计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。
比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用
None
根据Python的缩进规则，如果
也可以给
None
注意不要少写了冒号
当然上面的判断是很粗略的，完全可以用
None
None
None
None
None
None
None
只要
再议 input
最后看一个有问题的条件判断。很多同学会用
None
输入
None
这是因为
None
再次运行，就可以得到正确地结果。但是，如果输入
None
原来
如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。
练习
小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：


用

# -*- coding: utf-8 -*-

height = 1.75
weight = 80.5
----
bmi = ???
if ???:
    pass

小结
条件判断可以让计算机自己做选择，Python的if...elif...else很灵活。
None
参考源码
None
<br><br><br>循环<br>============
循环
要计算1+2+3，我们可以直接写表达式：
None
要计算1+2+3+...+10，勉强也能写出来。
但是，要计算1+2+3+...+10000，直接写表达式就不可能了。
为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。
Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：
None
执行这段代码，会依次打印
None
所以
再比如我们想计算1-10的整数之和，可以用一个
None
如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个
None
None
None
请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。
第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：
None
在循环内部变量
练习
请利用循环依次对list中的每个名字打印出

# -*- coding: utf-8 -*-
L = ['Bart', 'Lisa', 'Adam']

break
在循环中，
None
上面的代码可以打印出1~100。
如果要提前结束循环，可以用
None
执行上面的代码可以看到，打印出1~10后，紧接着打印
可见
continue
在循环过程中，也可以通过
None
上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用
None
执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。
可见
小结
循环是让计算机做重复任务的有效的方法。
None
None
有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用
请试写一个死循环程序。
参考源码
None
None
<br><br><br>使用dict和set<br>============
dict
Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。
举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：
None
给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。
如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：
None
为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。
第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。
dict就是第二种实现方式，给定一个名字，比如
你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。
把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
None
由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
None
如果key不存在，dict就会报错：
None
要避免key不存在的错误，有两种办法，一是通过
None
二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value：
None
注意：返回
要删除一个key，用
None
请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。
和list比较，dict有以下几个特点：


而list相反：


所以，dict是用空间来换取时间的一种方法。
dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是
这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。
要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：
None
set
set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
要创建一个set，需要提供一个list作为输入集合：
None
注意，传入的参数
重复元素在set中自动被过滤：
None
通过
None
通过
None
set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：
None
set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。
再议不可变对象
上面我们讲了，str是不变对象，而list是可变对象。
对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：
None
而对于不可变对象，比如str，对str进行操作呢：
None
虽然字符串有个
我们先把代码改成下面这样：
None
要始终牢记的是，
None
当我们调用
None
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
小结
使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。
tuple虽然是不变对象，但试试把
参考源码
None
None
<br><br><br>函数<br>============
我们知道圆的面积计算公式为：
S = πr
当我们知道半径
None
当代码出现有规律的重复的时候，你就需要当心了，每次写
有了函数，我们就不再每次写
基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。
抽象
抽象是数学中非常常见的概念。举个例子：
计算数列的和，比如：
100
None
n=1
这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。
而且，这种抽象记法是可扩展的，比如：
100
None
n=1
还原成加法运算就变成了：
(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)
可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。
写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。
<br><br><br>调用函数<br>============
Python内置了很多有用的函数，我们可以直接调用。
要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数
None
也可以在交互式命令行通过
调用
None
调用函数的时候，如果传入的参数数量不对，会报
None
如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报
None
而
None
数据类型转换
Python内置的常用函数还包括数据类型转换函数，比如
None
函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：
None
练习
请利用Python内置的

# -*- coding: utf-8 -*-

n1 = 255
n2 = 1000
----
print(???)

小结
调用Python的函数，需要根据函数定义，传入正确的参数。如果函数调用出错，一定要学会看错误信息，所以英文很重要！
参考源码
None
<br><br><br>定义函数<br>============
在Python中，定义一个函数要使用
我们以自定义一个求绝对值的
None
请自行测试并调用
请注意，函数体内部的语句在执行时，一旦执行到
如果没有
None
在Python交互环境中定义函数时，注意Python会出现
None
如果你已经把


None
空函数
如果想定义一个什么事也不做的空函数，可以用
None
None
None
None
缺少了
参数检查
调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出
None
但是如果参数类型不对，Python解释器就无法帮我们检查。试试
None
当传入了不恰当的参数时，内置函数
让我们修改一下
None
添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：
None
错误和异常处理将在后续讲到。
返回多个值
函数可以返回多个值吗？答案是肯定的。
比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标：
None
None
然后，我们就可以同时获得返回值：
None
但其实这只是一种假象，Python函数返回的仍然是单一值：
None
原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。
小结
定义函数时，需要确定函数名和参数个数；
如果有必要，可以先对参数的数据类型做检查；
函数体内部可以用
函数执行完毕也没有
函数可以同时返回多个值，但其实就是一个tuple。
练习
请定义一个函数
ax
的两个解。
提示：计算平方根可以调用
None

# -*- coding: utf-8 -*-

import math

def quadratic(a, b, c):
----
    pass
----
# 测试:
print(quadratic(2, 3, 1)) # => (-0.5, -1.0)
print(quadratic(1, 3, -4)) # => (1.0, -4.0)

参考源码
None
<br><br><br>函数的参数<br>============
定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。
Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。
位置参数
我们先写一个计算x
None
对于
当我们调用
None
现在，如果我们要计算x
你也许想到了，可以把
None
对于这个修改后的
None
修改后的
默认参数
新的
None
Python的错误信息很明确：调用函数
这个时候，默认参数就排上用场了。由于我们经常计算x
None
这样，当我们调用
None
而对于
从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：
一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
二是如何设置默认参数。
当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
使用默认参数有什么好处？最大的好处是能降低调用函数的难度。
举个例子，我们写个一年级小学生注册的函数，需要传入
None
这样，调用
None
如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。
我们可以把年龄和城市设为默认参数：
None
这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：
None
只有与默认参数不符的学生才需要提供额外的信息：
None
可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。
有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用
也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用
默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：
先定义一个函数，传入一个list，添加一个
None
当你正常调用时，结果似乎不错：
None
当你使用默认参数调用时，一开始结果也是对的：
None
但是，再次调用
None
很多初学者很疑惑，默认参数是
原因解释如下：
Python函数在定义的时候，默认参数
所以，定义默认参数要牢记一点：默认参数必须指向不变对象！
要修改上面的例子，我们可以用
None
现在，无论调用多少次，都不会有问题：
None
为什么要设计
可变参数
在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。
我们以数学题为例子，给定一组数字a，b，c……，请计算a
要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：
None
但是调用的时候，需要先组装出一个list或tuple：
None
如果利用可变参数，调用函数的方式可以简化成这样：
None
所以，我们把函数的参数改为可变参数：
None
定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个
None
如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：
None
这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个
None
None
关键字参数
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：
None
函数
None
也可以传入任意个数的关键字参数：
None
关键字参数有什么用？它可以扩展函数的功能。比如，在
和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：
None
当然，上面复杂的调用可以用简化的写法：
None
None
命名关键字参数
对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过
仍以
None
但是调用者仍可以传入不受限制的关键字参数：
None
如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收
None
和关键字参数
调用方式如下：
None
如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符
None
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：
None
由于调用时缺少参数名
命名关键字参数可以有缺省值，从而简化调用：
None
由于命名关键字参数
None
使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个
None
参数组合
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
比如定义一个函数，包含上述若干种参数：
None
在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。
None
最神奇的是通过一个tuple和dict，你也可以调用上述函数：
None
所以，对于任意函数，都可以通过类似
小结
Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。
默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！
要注意定义可变参数和关键字参数的语法：
None
None
以及调用函数时如何传入可变参数和关键字参数的语法：
可变参数既可以直接传入：
关键字参数既可以直接传入：
使用
命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符
参考源码
None
None
<br><br><br>递归函数<br>============
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。
举个例子，我们来计算阶乘
fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n
所以，
于是，
None
上面就是一个递归函数。可以试试：
None
如果我们计算
None
递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试
None
解决递归调用栈溢出的方法是通过
尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
上面的
None
可以看到，
None
None
尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的
小结
使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。
Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。
练习
None
请编写

def move(n, a, b, c):
----
    pass
----
# 期待输出:
# A --> C
# A --> B
# C --> B
# A --> C
# B --> A
# B --> C
# A --> C
move(3, 'A', 'B', 'C')

参考源码
None
<br><br><br>高级特性<br>============
掌握了Python的数据类型、语句和函数，基本上就可以编写出很多有用的程序了。
比如构造一个
None
取list的前一半的元素，也可以通过循环实现。
但是在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。
基于这一思想，我们来介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。
<br><br><br>切片<br>============
取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：
None
取前3个元素，应该怎么做？
笨办法：
None
之所以是笨办法是因为扩展一下，取前N个元素就没辙了。
取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：
None
对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。
对应上面的问题，取前3个元素，用一行代码就可以完成切片：
None
None
如果第一个索引是
None
也可以从索引1开始，取出2个元素出来：
None
类似的，既然Python支持
None
记住倒数第一个元素的索引是
切片操作十分有用。我们先创建一个0-99的数列：
None
可以通过切片轻松取出某一段数列。比如前10个数：
None
后10个数：
None
前11-20个数：
None
前10个数，每两个取一个：
None
所有数，每5个取一个：
None
甚至什么都不写，只写
None
tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：
None
字符串
None
在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。
小结
有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。
参考源码
None
<br><br><br>迭代<br>============
如果给定一个list或tuple，我们可以通过
在Python中，迭代是通过
None
可以看出，Python的
list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：
None
因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。
默认情况下，dict迭代的是key。如果要迭代value，可以用
由于字符串也是可迭代对象，因此，也可以作用于
None
所以，当我们使用
那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：
None
最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的
None
上面的
None
小结
任何可迭代对象都可以作用于
参考源码
None
<br><br><br>列表生成式<br>============
列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。
举个例子，要生成list 
None
但如果要生成
None
但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：
None
写列表生成式时，把要生成的元素
for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：
None
还可以使用两层循环，可以生成全排列：
None
三层和三层以上的循环就很少用到了。
运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：
None
None
None
因此，列表生成式也可以使用两个变量来生成list：
None
最后把一个list中所有的字符串变成小写：
None
练习
如果list中既包含字符串，又包含整数，由于非字符串类型没有
None
使用内建的
None
请修改列表生成式，通过添加

# -*- coding: utf-8 -*-

L1 = ['Hello', 'World', 18, 'Apple', None]
----
L2 = ???
----
# 期待输出: ['hello', 'world', 'apple']
print(L2)

小结
运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。
参考源码
None
<br><br><br>生成器<br>============
通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。
所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。
要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的
None
创建
我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？
如果要一个一个打印出来，可以通过
None
我们讲过，generator保存的是算法，每次调用
当然，上面这种不断调用
None
所以，我们创建了一个generator后，基本上永远不会调用
generator非常强大。如果推算的算法比较复杂，用类似列表生成式的
比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：
None
None
None
相当于：
None
但不必显式写出临时变量t就可以赋值。
上面的函数可以输出斐波那契数列的前N个数：
None
仔细观察，可以看出，
也就是说，上面的函数和generator仅一步之遥。要把
None
这就是定义generator的另一种方法。如果一个函数定义中包含
None
这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到
举个简单的例子，定义一个generator，依次返回数字1，3，5：
None
调用该generator时，首先要生成一个generator对象，然后用
None
可以看到，
回到
同样的，把函数改成generator后，我们基本上从来不会用
None
但是用
None
关于如何捕获错误，后面的错误处理还会详细讲解。
练习
None
None
把每一行看做一个list，试写一个generator，不断输出下一行的list：

# -*- coding: utf-8 -*-

def triangles():
----
    pass
----
# 期待输出:
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]
# [1, 7, 21, 35, 35, 21, 7, 1]
# [1, 8, 28, 56, 70, 56, 28, 8, 1]
# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]
n = 0
for t in triangles():
    print(t)
    n = n + 1
    if n == 10:
        break

小结
generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。
要理解generator的工作原理，它是在
请注意区分普通函数和generator函数，普通函数调用直接返回结果：
None
generator函数的“调用”实际返回一个generator对象：
None
参考源码
None
<br><br><br>迭代器<br>============
我们已经知道，可以直接作用于
一类是集合数据类型，如
一类是
这些可以直接作用于
可以使用
None
而生成器不但可以作用于
可以被
可以使用
None
生成器都是
把
None
你可能会问，为什么
这是因为Python的
None
小结
凡是可作用于
凡是可作用于
集合数据类型如
Python的
None
实际上完全等价于：
None
参考源码
None
<br><br><br>函数式编程<br>============
函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。
而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。
我们首先要搞明白计算机（Computer）和计算（Compute）的概念。
在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。
而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。
对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。
函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。
<br><br><br>高阶函数<br>============
高阶函数英文叫Higher-order function。什么是高阶函数？我们以实际代码为例子，一步一步深入概念。
变量可以指向函数
以Python内置的求绝对值的函数
None
但是，如果只写
None
可见，
要获得函数调用结果，我们可以把结果赋值给变量：
None
但是，如果把函数本身赋值给变量呢？
None
结论：函数本身也可以赋值给变量，即：变量可以指向函数。
如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：
None
成功！说明变量
函数名也是变量
那么函数名是什么呢？函数名其实就是指向函数的变量！对于
如果把
None
把
当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复
注：由于
传入函数
既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
一个最简单的高阶函数：
None
当我们调用
None
用代码验证一下：
None
编写高阶函数，就是让函数的参数能够接收别的函数。
小结
把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。
<br><br><br>map/reduce<br>============
Python内建了
如果你读过Google的那篇大名鼎鼎的论文“
我们先看map。
举例说明，比如我们有一个函数f(x)=x
None
现在，我们用Python代码实现：
None
None
你可能会想，不需要
None
的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？
所以，
None
只需要一行代码。
再看
None
比方说对一个序列求和，就可以用
None
当然求和运算可以直接用Python内建函数
但是如果要把序列
None
这个例子本身没多大用处，但是，如果考虑到字符串
None
整理成一个
None
还可以用lambda函数进一步简化成：
None
也就是说，假设Python没有提供
lambda函数的用法在后面介绍。
练习
利用

# -*- coding: utf-8 -*-
----
def normalize(name):
    pass
----
# 测试:
L1 = ['adam', 'LISA', 'barT']
L2 = list(map(normalize, L1))
print(L2)

Python提供的

# -*- coding: utf-8 -*-

from functools import reduce

def prod(L):
----
    pass
----
print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))

利用

# -*- coding: utf-8 -*-

from functools import reduce

def str2float(s):
----
    pass
----
print('str2float(\'123.456\') =', str2float('123.456'))

参考代码
None
None
<br><br><br>filter<br>============
Python内建的
和
例如，在一个list中，删掉偶数，只保留奇数，可以这么写：
None
把一个序列中的空字符串删掉，可以这么写：
None
可见用
注意到
用filter求素数
计算
首先，列出从
2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取序列的第一个数
3, 
取新序列的第一个数
5, 
取新序列的第一个数
7, 
不断筛下去，就可以得到所有的素数。
用Python来实现这个算法，可以先构造一个从
None
注意这是一个生成器，并且是一个无限序列。
然后定义一个筛选函数：
None
最后，定义一个生成器，不断返回下一个素数：
None
这个生成器先返回第一个素数
由于
None
注意到
练习
回数是指从左向右读和从右向左读都是一样的数，例如

# -*- coding: utf-8 -*-

def is_palindrome(n):
----
    pass
----
# 测试:
output = filter(is_palindrome, range(1, 1000))
print(list(output))

小结
None
参考源码
None
None
<br><br><br>sorted<br>============
排序算法
排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。
Python内置的
None
此外，
None
key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过
None
然后
None
我们再看一个字符串排序的例子：
None
默认情况下，对字符串排序，是按照ASCII的大小比较的，由于
现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。
这样，我们给
None
要进行反向排序，不必改动key函数，可以传入第三个参数
None
从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。
小结
None
练习
假设我们用一组tuple表示学生名字和成绩：
None
请用

# -*- coding: utf-8 -*-

L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

def by_name(t):
----
    pass
----
L2 = sorted(L, key=by_name)
print(L2)

再按成绩从高到低排序：

# -*- coding: utf-8 -*-

L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

----
def by_score(t):
    pass

L2 = ???
----
print(L2)

参考源码
None
<br><br><br>返回函数<br>============
函数作为返回值
高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：
None
但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：
None
当我们调用
None
调用函数
None
在这个例子中，我们在函数
请再注意一点，当我们调用
None
None
闭包
注意到返回的函数在其定义内部引用了局部变量
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了
None
在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。
你可能认为调用
None
全部都是
返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
None
再看看结果：
None
缺点是代码较长，可利用lambda函数缩短代码。
小结
一个函数可以返回一个计算结果，也可以返回一个函数。
返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。
参考源码
None
<br><br><br>匿名函数<br>============
当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。
在Python中，对匿名函数提供了有限支持。还是以
None
通过对比可以看出，匿名函数
None
关键字
匿名函数有个限制，就是只能有一个表达式，不用写
用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：
None
同样，也可以把匿名函数作为返回值返回，比如：
None
小结
Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。
<br><br><br>装饰器<br>============
由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。
None
函数对象有一个
None
现在，假设我们要增强
本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：
None
观察上面的
None
调用
None
把
None
由于
None
如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：
None
这个3层嵌套的decorator用法如下：
None
执行结果如下：
None
和两层嵌套的decorator相比，3层嵌套的效果是这样的：
None
我们来剖析上面的语句，首先执行
以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有
None
因为返回的那个
不需要编写
None
或者针对带参数的decorator：
None
None
小结
在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。
decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。
请编写一个decorator，能在函数调用的前后打印出
再思考一下能否写出一个
None
又支持：
None
参考源码
None
<br><br><br>偏函数<br>============
Python的
在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：
None
None
但
None
假设要转换大量的二进制字符串，每次都传入
None
这样，我们转换二进制就非常方便了：
None
None
None
所以，简单总结
注意到上面的新的
None
最后，创建偏函数时，实际上可以接收函数对象、
None
实际上固定了int()函数的关键字参数
None
相当于：
None
当传入：
None
实际上会把
None
相当于：
None
结果为
小结
当函数的参数个数太多，需要简化时，使用
参考源码
None
<br><br><br>模块<br>============
在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。
使用模块有什么好处？
最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。
使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点
你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。
举个例子，一个
现在，假设我们的
None
引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，
请注意，每一个包目录下面都会有一个
类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：
None
文件
自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了
None
<br><br><br>使用模块<br>============
Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。
我们以内建的
None
第1行和第2行是标准注释，第1行注释可以让这个
第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；
第6行使用
以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。
后面开始就是真正的代码部分。
你可能注意到了，使用
None
导入
None
运行
运行
最后，注意到这两行代码：
None
当我们在命令行运行
我们可以用命令行运行
None
如果启动Python交互环境，再导入
None
导入时，没有打印
调用
None
作用域
在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过
正常的函数和变量名是公开的（public），可以被直接引用，比如：
类似
类似
之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。
private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：
None
我们在模块里公开
外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。
<br><br><br>安装第三方模块<br>============
在Python中，安装第三方模块，是通过包管理工具pip完成的。
如果你正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。
如果你正在使用Windows，请参考
在命令提示符窗口下尝试运行
注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是
现在，让我们来安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。
一般来说，第三方库都会在Python官方的
None
耐心等待下载并安装后，就可以使用Pillow了。
有了Pillow，处理图片易如反掌。随便找个图片生成缩略图：
None
其他常用的第三方库还有MySQL的驱动：
模块搜索路径
当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：
None
默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在
None
如果我们要添加自己的搜索目录，有两种方法：
一是直接修改
None
这种方法是在运行时修改，运行结束后失效。
第二种方法是设置环境变量
<br><br><br>面向对象编程<br>============
面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。
面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。
而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。
在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。
我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。
假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：
None
而处理学生成绩可以通过函数实现，比如打印学生的成绩：
None
如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是
None
给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
None
面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。
所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。
面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。
小结
数据封装、继承和多态是面向对象的三大特点，我们后面会详细讲解。
<br><br><br>类和实例<br>============
面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。
仍以Student类为例，在Python中，定义类是通过
None
None
定义好了
None
可以看到，变量
可以自由地给一个实例变量绑定属性，比如，给实例
None
由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的
None
None
注意到
有了
None
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量
数据封装
面向对象编程的一个重要特点就是数据封装。在上面的
None
但是，既然
None
要定义一个方法，除了第一个参数是
None
这样一来，我们从外部看
封装的另一个好处是可以给
None
同样的，
None
小结
类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；
方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；
通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。
和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：
None
参考源码
None
<br><br><br>访问限制<br>============
在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。
但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的
None
如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线
None
改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问
None
这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。
但是如果外部代码要获取name和score怎么办？可以给Student类增加
None
如果又要允许外部代码修改score怎么办？可以再给Student类增加
None
你也许会问，原先那种直接通过
None
需要注意的是，在Python中，变量名类似
有些时候，你会看到以一个下划线开头的实例变量名，比如
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问
None
但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把
总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。
最后注意下面的这种错误写法：
None
表面上看，外部代码“成功”地设置了
None
参考源码
None
<br><br><br>继承和多态<br>============
在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。
比如，我们已经编写了一个名为
None
当我们需要编写
None
对于
继承有什么好处？最大的好处是子类获得了父类的全部功能。由于
None
运行结果如下：
None
当然，也可以对子类增加一些方法，比如Dog类：
None
继承的第二个好处需要我们对代码做一点改进。你看到了，无论是
None
再次运行，结果如下：
None
当子类和父类都存在相同的
要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：
None
判断一个变量是否是某个类型可以用
None
看来
但是等等，试试：
None
看来
不过仔细想想，这是有道理的，因为
所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：
None
None
要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个
None
当我们传入
None
当我们传入
None
当我们传入
None
看上去没啥意思，但是仔细想想，现在，如果我们再定义一个
None
当我们调用
None
你会发现，新增一个
多态的好处就是，当我们需要传入
对于一个变量，我们只需要知道它是
对扩展开放：允许新增
对修改封闭：不需要修改依赖
继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：
None
静态语言 vs 动态语言
对于静态语言（例如Java）来说，如果需要传入
对于Python这样的动态语言来说，则不一定需要传入
None
这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。
Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个
小结
继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。
动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。
参考源码
None
<br><br><br>获取对象信息<br>============
当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？
使用type()
首先，我们来判断对象类型，使用
基本类型都可以用
None
如果一个变量指向函数或者类，也可以用
None
但是
None
判断基本数据类型可以直接写
None
使用isinstance()
对于class的继承关系来说，使用
我们回顾上次的例子，如果继承关系是：
None
那么，
None
然后，判断：
None
没有问题，因为
再判断：
None
None
因此，我们可以确信，
None
同理，实际类型是Dog的
None
但是，
None
能用
None
并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：
None
使用dir()
如果要获得一个对象的所有属性和方法，可以使用
None
类似
None
我们自己写的类，如果也想用
None
剩下的都是普通属性或方法，比如
None
仅仅把属性和方法列出来是不够的，配合
None
紧接着，可以测试该对象的属性：
None
如果试图获取不存在的属性，会抛出AttributeError的错误：
None
可以传入一个default参数，如果属性不存在，就返回默认值：
None
也可以获得对象的方法：
None
小结
通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：
None
就不要写：
None
一个正确的用法的例子如下：
None
假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。
请注意，在Python这类动态语言中，根据鸭子类型，有
参考源码
None
None
<br><br><br>实例属性和类属性<br>============
由于Python是动态语言，根据类创建的实例可以任意绑定属性。
给实例绑定属性的方法是通过实例变量，或者通过
None
但是，如果
None
当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：
None
从上面的例子可以看出，在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。
<br><br><br>面向对象高级编程<br>============
数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能。
我们会讨论多重继承、定制类、元类等概念。
<br><br><br>使用__slots__<br>============
正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：
None
然后，尝试给实例绑定一个属性：
None
还可以尝试给实例绑定一个方法：
None
但是，给一个实例绑定的方法，对另一个实例是不起作用的：
None
为了给所有实例都绑定方法，可以给class绑定方法：
None
给class绑定方法后，所有实例均可调用：
None
通常情况下，上面的
使用__slots__
但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加
为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的
None
然后，我们试试：
None
由于
使用
None
除非在子类中也定义
参考源码
None
<br><br><br>使用@property<br>============
在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：
None
这显然不合逻辑。为了限制score的范围，可以通过一个
None
现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：
None
但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。
有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！
还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的
None
None
None
注意到这个神奇的
还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：
None
上面的
小结
None
练习
请利用

# -*- coding: utf-8 -*-

class Screen(object):
----
    pass
----
# test:
s = Screen()
s.width = 1024
s.height = 768
print(s.resolution)
assert s.resolution == 786432, '1024 * 768 = %d ?' % s.resolution

参考源码
None
<br><br><br>多重继承<br>============
继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。
回忆一下


如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：
None
但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：
None
如果要把上面的两种分类都包含进来，我们就得设计更多的层次：


这么一来，类的层次就复杂了：
None
如果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。
正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：
None
现在，我们要给动物再加上
None
对于需要
None
对于需要
None
通过多重继承，一个子类就可以同时获得多个父类的所有功能。
MixIn
在设计类的继承关系时，通常，主线都是单一继承下来的，例如，
为了更好地看出继承关系，我们把
None
MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。
Python自带的很多库也使用了MixIn。举个例子，Python自带了
比如，编写一个多进程模式的TCP服务，定义如下：
None
编写一个多线程模式的UDP服务，定义如下：
None
如果你打算搞一个更先进的协程模型，可以编写一个
None
这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。
小结
由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。
只允许单一继承的语言（如Java）不能使用MixIn的设计。
<br><br><br>定制类<br>============
看到类似
None
除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。
__str__
我们先定义一个
None
打印出一堆
怎么才能打印得好看呢？只需要定义好
None
这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。
但是细心的朋友会发现直接敲变量不用
None
这是因为直接显示变量调用的不是
解决办法是再定义一个
None
__iter__
如果一个类想被用于
我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：
None
现在，试试把Fib实例作用于for循环：
None
__getitem__
Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：
None
要表现得像list那样按照下标取出元素，需要实现
None
现在，就可以按下标访问数列的任意一项了：
None
但是list有个神奇的切片方法：
None
对于Fib却报错。原因是
None
现在试试Fib的切片：
None
但是没有对step参数作处理：
None
也没有对负数作处理，所以，要正确实现一个
此外，如果把对象看成
与之对应的是
总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。
__getattr__
正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义
None
调用
None
错误信息很清楚地告诉我们，没有找到
要避免这个错误，除了可以加上一个
None
当调用不存在的属性时，比如
None
返回函数也是完全可以的：
None
只是调用方式要变为：
None
注意，只有在没有找到属性的情况下，才调用
此外，注意到任意调用如
None
这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。
这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。
举个例子：
现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：


如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。
利用完全动态的
None
试试：
None
这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！
还有些REST API会把参数放到URL中，比如GitHub的API：
None
调用时，需要把
None
就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。
__call__
一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用
任何类，只需要定义一个
None
调用方式如下：
None
None
如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。
那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个
None
通过
小结
Python的class允许定义许多定制方法，可以让我们非常方便地生成特定的类。
本节介绍的是最常用的几个定制方法，还有很多可定制的方法，请参考
参考源码
None
None
None
None
None
<br><br><br>使用枚举类<br>============
当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：
None
好处是简单，缺点是类型是
更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了
None
这样我们就获得了
None
None
如果需要更精确地控制枚举类型，可以从
None
None
访问这些枚举类型可以有若干种方法：
None
可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。
小结
None
参考源码
None
<br><br><br>使用元类<br>============
type()
动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。
比方说我们要定义一个
None
当Python解释器载入
None
None
我们说class的定义是运行时动态创建的，而创建class的方法就是使用
None
None
要创建一个class对象，


通过
正常情况下，我们都用
metaclass
除了使用
metaclass，直译为元类，简单的解释就是：
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。
但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。
连接起来就是：先定义metaclass，就可以创建类，最后创建实例。
所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。
metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。
我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个
定义
None
有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数
None
当我们传入关键字参数
None


测试一下
None
而普通的
None
动态修改有什么意义？直接在
但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。
ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。
要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。
让我们来尝试编写一个ORM框架。
编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个
None
其中，父类
现在，我们就按上面的接口来实现该ORM。
首先来定义
None
在
None
下一步，就是编写最复杂的
None
以及基类
None
当用户定义一个
在


在
我们实现了
编写代码试试：
None
输出如下：
None
可以看到，
不到100行代码，我们就通过metaclass实现了一个精简的ORM框架。
小结
metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。
参考源码
None
None
None
<br><br><br>错误、调试和测试<br>============
在程序运行过程中，总会遇到各种各样的错误。
有的错误是程序编写有问题造成的，比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为bug，bug是必须修复的。
有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理。
还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。
Python内置了一套异常处理机制，来帮助我们进行错误处理。
此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。
最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。
<br><br><br>错误处理<br>============
在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数
用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错：
None
一旦出错，还要一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。
所以高级语言通常都内置了一套
try
让我们用一个例子来看看
None
当我们认为某些代码可能会出错时，就可以用
上面的代码在计算
None
从输出可以看到，当错误发生时，后续语句
如果把除数
None
由于没有错误发生，所以
你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的
None
None
此外，如果没有错误发生，可以在
None
Python的错误其实也是class，所有的错误类型都继承自
None
第二个
Python所有的错误都是从
None
使用
None
也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写
调用堆栈
如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。来看看
None
执行，结果如下：
None
出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链：
错误信息第1行：
None
告诉我们这是错误的跟踪信息。
第2~3行：
None
调用
None
调用
None
原因是
None
原因是
None
根据错误类型
记录错误
如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。
Python内置的
None
同样是出错，但程序打印完错误信息后会继续执行，并正常退出：
None
通过配置，
抛出错误
因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。
如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用
None
执行，可以最后跟踪到我们自己定义的错误：
None
只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如
最后，我们来看另一种错误处理的方式：
None
在
其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。
None
None
只要是合理的转换逻辑就可以，但是，决不应该把一个
小结
Python内置的
程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。
参考源码
None
None
None
None
None
<br><br><br>调试<br>============
程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。
第一种方法简单直接粗暴有效，就是用
None
执行后在输出中查找打印的变量值：
None
用
断言
凡是用
None
None
如果断言失败，
None
程序中如果到处充斥着
None
关闭后，你可以把所有的
logging
把
None
None
别急，在
None
看到输出了：
None
这就是
None
pdb
第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：
None
然后启动：
None
以参数
None
输入命令
None
任何时候都可以输入命令
None
输入命令
None
这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。
pdb.set_trace()
这个方法也是用pdb，但是不需要单步执行，我们只需要
None
运行代码，程序会自动在
None
这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。
IDE
如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有PyCharm：
None
另外，
小结
写程序最痛苦的事情莫过于调试，程序往往会以你意想不到的流程来运行，你期待执行的语句其实根本没有执行，这时候，就需要调试了。
虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。
参考源码
None
None
None
<br><br><br>单元测试<br>============
如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。
单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。
比如对函数


把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。
如果单元测试通过，说明我们测试的这个函数能够正常工作。如果单元测试不通过，要么函数有bug，要么测试条件输入不正确，总之，需要修复使单元测试能够通过。
单元测试通过后有什么意义呢？如果我们对
这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。
我们来编写一个
None
None
None
为了编写单元测试，我们需要引入Python自带的
None
编写单元测试时，我们需要编写一个测试类，从
以
对每一类测试都需要编写一个
None
另一种重要的断言就是期待抛出指定类型的Error，比如通过
None
而通过
None
运行单元测试
一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在
None
这样就可以把
None
另一种方法是在命令行通过参数
None
这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。
setUp与tearDown
可以在单元测试中编写两个特殊的
None
None
可以再次运行测试看看每个测试方法调用前后是否会打印出
小结
单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。
单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。
单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。
单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。
参考源码
None
None
<br><br><br>文档测试<br>============
如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如
None
可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。
这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？
答案是肯定的。
当我们编写注释时，如果写上这样的注释：
None
无疑更明确地告诉函数的调用者该函数的期望输入和输出。
并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。
doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用
让我们用doctest来测试上次编写的
None
运行
None
什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，比如把
None
注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。
练习
对函数

# -*- coding: utf-8 -*-

def fact(n):
    '''
----
----
    '''
    if n < 1:
        raise ValueError()
    if n == 1:
        return 1
    return n * fact(n - 1)

if __name__ == '__main__':
    import doctest
    doctest.testmod()

小结
doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。
参考源码
None
<br><br><br>IO编程<br>============
IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。
比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。
IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。
由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：
第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；
另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。
同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。
你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是异步IO。
很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。
操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。
注意，本章的IO编程都是同步模式，异步IO由于复杂度太高，后续涉及到服务器端程序开发时我们再讨论。
<br><br><br>文件读写<br>============
读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。
读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。
读文件
要以读文件的模式打开一个文件对象，使用Python内置的
None
标示符'r'表示读，这样，我们就成功地打开了一个文件。
如果文件不存在，
None
如果文件打开成功，接下来，调用
None
最后一步是调用
None
由于文件读写时都有可能产生
None
但是每次都这么写实在太繁琐，所以，Python引入了
None
这和前面的
调用
如果文件很小，
None
file-like Object
像
None
二进制文件
前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用
None
字符编码
要读取非UTF-8编码的文本文件，需要给
None
遇到有些编码不规范的文件，你可能会遇到
None
写文件
写文件和读文件是一样的，唯一区别是调用
None
你可以反复调用
None
要写入特定编码的文本文件，请给
小结
在Python中，文件读写是通过
参考源码
None
<br><br><br>StringIO和BytesIO<br>============
StringIO
很多时候，数据读写不一定是文件，也可以在内存中读写。
StringIO顾名思义就是在内存中读写str。
要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：
None
None
要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：
None
BytesIO
StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。
BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：
None
请注意，写入的不是str，而是经过UTF-8编码的bytes。
和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：
None
小结
StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。
参考源码
None
None
<br><br><br>操作文件和目录<br>============
如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如
如果要在Python程序中执行这些目录和文件的操作怎么办？其实操作系统提供的命令只是简单地调用了操作系统提供的接口函数，Python内置的
打开Python交互式命令行，我们来看看如何使用
None
如果是
要获取详细的系统信息，可以调用
None
注意
环境变量
在操作系统中定义的环境变量，全部保存在
None
要获取某个环境变量的值，可以调用
None
操作文件和目录
操作文件和目录的函数一部分放在
None
把两个路径合成一个时，不要直接拼字符串，而要通过
None
而Windows下会返回这样的字符串：
None
同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过
None
None
None
这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。
文件操作使用下面的函数。假定当前目录下有一个
None
但是复制文件的函数居然在
幸运的是
最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码：
None
要列出所有的
None
是不是非常简洁？
小结
Python的
练习


参考源码
None
<br><br><br>序列化<br>============
在程序运行的过程中，所有的变量都是在内存中，比如，定义一个dict：
None
可以随时修改变量，比如把
我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。
序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。
反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。
Python提供了
首先，我们尝试把一个对象序列化并写入文件：
None
None
None
看看写入的
当我们要把对象从磁盘读到内存时，可以先把内容读到一个
None
变量的内容又回来了！
当然，这个变量和原来的变量是完全不相干的对象，它们只是内容相同而已。
Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。
JSON
如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。
JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：


Python内置的
None
None
要把JSON反序列化为Python对象，用
None
由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的
JSON进阶
Python的
None
运行代码，毫不留情地得到一个
None
错误的原因是
如果连
别急，我们仔细看看
None
这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把
可选参数
None
这样，
None
不过，下次如果遇到一个
None
因为通常
同样的道理，如果我们要把JSON反序列化为一个
None
运行结果如下：
None
打印出的是反序列化的
小结
Python语言特定的序列化模块是
None
参考源码
None
None
<br><br><br>进程和线程<br>============
很多同学都听说过，现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。
什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。
现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？
答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。
真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。
对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。
有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。
由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。
我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？
有两种解决方案：
一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。
还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。
当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。
总结一下就是，多任务的实现有3种方式：


同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。
因为复杂度高，调试困难，所以，不是迫不得已，我们也不想编写多任务。但是，有很多时候，没有多任务还真不行。想想在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频，否则，单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频，这显然是不行的。
Python既支持多进程，又支持多线程，我们会讨论如何编写这两种多任务程序。
小结
线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。
多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。
<br><br><br>多进程<br>============
要让Python程序实现多进程（multiprocessing），我们先了解操作系统的相关知识。
Unix/Linux操作系统提供了一个
子进程永远返回
Python的
None
运行结果如下：
None
由于Windows没有
有了
multiprocessing
如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有
由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。
None
None
执行结果如下：
None
创建子进程时，只需要传入一个执行函数和函数的参数，创建一个
None
Pool
如果要启动大量的子进程，可以用进程池的方式批量创建子进程：
None
执行结果如下：
None
代码解读：
对
请注意输出的结果，task 
None
就可以同时跑5个进程。
由于
子进程
很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。
None
下面的例子演示了如何在Python代码中运行命令
None
运行结果：
None
如果子进程还需要输入，则可以通过
None
上面的代码相当于在命令行执行命令
None
运行结果如下：
None
进程间通信
None
我们以
None
运行结果如下：
None
在Unix/Linux下，
小结
在Unix/Linux下，可以使用
要实现跨平台的多进程，可以使用
进程间通信是通过
参考源码
None
None
None
None
None
<br><br><br>多线程<br>============
多任务可以由多进程完成，也可以由一个进程内的多线程完成。
我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。
由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。
Python的标准库提供了两个模块：
启动一个线程就是把一个函数传入并创建
None
执行结果如下：
None
由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的
Lock
多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。
来看看多个线程同时操作一个变量怎么把内容给改乱了：
None
我们定义了一个共享变量
原因是因为高级语言的一条语句在CPU执行时是若干条语句，即使一个简单的计算：
None
也分两步：


也就是可以看成：
None
由于x是局部变量，两个线程各自都有自己的x，当代码正常执行时：
None
但是t1和t2是交替运行的，如果操作系统以下面的顺序执行t1、t2：
None
究其原因，是因为修改
两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙地变成了负数，所以，我们必须确保一个线程在修改
如果我们要确保
None
当多个线程同时执行
获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用
锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。
多核CPU
如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。
如果写一个死循环的话，会出现什么情况呢？
打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。
我们可以监控到一个死循环线程会100%占用一个CPU。
如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两个CPU核心。
要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。
试试用Python写个死循环：
None
启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。
但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？
因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。
GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。
所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。
不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。
小结
多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。
Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。
参考源码
None
None
<br><br><br>ThreadLocal<br>============
在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。
但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：
None
每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的
如果用一个全局
None
这种方式理论上是可行的，它最大的优点是消除了
有没有更简单的方式？
None
None
执行结果：
None
全局变量
可以理解为全局变量
None
小结
一个
参考源码
None
<br><br><br>进程 vs. 线程<br>============
我们介绍了多进程和多线程，这是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。
首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。
如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。
如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。
多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。
多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用
多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。
在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。
线程切换
无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？
我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。
如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型，或者批处理任务模型。
假设你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以幼儿园小朋友的眼光来看，你就正在同时写5科作业。
但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。
所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。
计算密集型 vs. IO密集型
是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。
计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。
第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。
IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。
异步IO
考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。
现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。
对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。
<br><br><br>分布式进程<br>============
在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。
Python的
举个例子：如果我们已经有一个通过
原有的
我们先看服务进程，服务进程负责启动
None
请注意，当我们在一台机器上写多进程程序时，创建的
然后，在另一台机器上启动任务进程（本机上启动也可以）：
None
任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。
现在，可以试试分布式进程的工作效果了。先启动
None
None
None
None
None
这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算
Queue对象存储在哪？注意到
None
而
None
小结
Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。
注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。
参考源码
None
None
<br><br><br>正则表达式<br>============
字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取
正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。
所以我们判断一个字符串是否是合法的Email的方法是：


因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。
在正则表达式中，如果直接给出字符，就是精确匹配。用


None


要匹配变长的字符，在正则表达式中，用
来看一个复杂的例子：
我们来从左到右解读一下：


综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。
如果要匹配
但是，仍然无法匹配
进阶
要做更精确地匹配，可以用


None
None
None
你可能注意到了，
re模块
有了准备知识，我们就可以在Python中使用正则表达式了。Python提供
None
因此我们强烈建议使用Python的
None
先看看如何判断正则表达式是否匹配：
None
None
None
切分字符串
用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：
None
嗯，无法识别连续的空格，用正则表达式试试：
None
无论多少个空格都可以正常分割。加入
None
再加入
None
如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。
分组
除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用
None
None
如果正则表达式中定义了组，就可以在
注意到
提取子串非常有用。来看一个更凶残的例子：
None
这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：
None
对于
贪婪匹配
最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的
None
由于
必须让
None
编译
当我们在Python中使用正则表达式时，re模块内部会干两件事情：


如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：
None
编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。
小结
正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。
练习
请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：
None
版本二可以验证并提取出带名字的Email地址：
None
参考源码
None
<br><br><br>常用内建模块<br>============
Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。
本章将介绍一些常用的内建模块。
<br><br><br>datetime<br>============
datetime是Python处理日期和时间的标准库。
获取当前日期和时间
我们先看如何获取当前日期和时间：
None
注意到
如果仅导入
None
获取指定日期和时间
要指定某个日期和时间，我们直接用参数构造一个
None
datetime转换为timestamp
在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为
你可以认为：
None
对应的北京时间是：
None
可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。
把一个
None
注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。
某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。
timestamp转换为datetime
要把timestamp转换为
None
注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。
本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：
None
实际上就是UTC+8:00时区的时间：
None
而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：
None
timestamp也可以直接被转换到UTC标准时区的时间：
None
str转换为datetime
很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过
None
字符串
注意转换后的datetime是没有时区信息的。
datetime转换为str
如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过
None
datetime加减
对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用
None
可见，使用
本地时间转换为UTC时间
本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。
一个
None
如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。
时区转换
我们可以先通过
None
时区转换的关键在于，拿到一个
利用带时区的
注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的
小结
None
如果要存储
练习
假设你获取了用户输入的日期和时间如

# -*- coding:utf-8 -*-

import re
from datetime import datetime, timezone, timedelta

def to_timestamp(dt_str, tz_str):
----
    pass
----
# 测试:

t1 = to_timestamp('2015-6-1 08:10:30', 'UTC+7:00')
assert t1 == 1433121030.0, t1

t2 = to_timestamp('2015-5-31 16:10:30', 'UTC-09:00')
assert t2 == 1433121030.0, t2

print('Pass')

参考源码
None
<br><br><br>collections<br>============
collections是Python内建的一个集合模块，提供了许多有用的集合类。
namedtuple
我们知道
None
但是，看到
定义一个class又小题大做了，这时，
None
None
这样一来，我们用
可以验证创建的
None
类似的，如果要用坐标和半径表示一个圆，也可以用
None
deque
使用
deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：
None
None
defaultdict
使用
None
注意默认值是调用函数返回的，而函数在创建
除了在Key不存在时返回默认值，
OrderedDict
使用
如果要保持Key的顺序，可以用
None
注意，
None
None
None
Counter
None
None
None
小结
None
参考源码
None
<br><br><br>base64<br>============
Base64是一种用64个字符来表示任意二进制数据的方法。
用记事本打开
Base64的原理很简单，首先，准备一个包含64个字符的数组：
None
然后，对二进制数据进行处理，每3个字节一组，一共是
None
这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。
所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。
如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用
Python内置的
None
由于标准的Base64编码后可能出现字符
None
还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。
Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。
Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。
由于
None
去掉
小结
Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。
练习
请写一个能处理去掉

# -*- coding: utf-8 -*-

import base64

def safe_base64_decode(s):
----
    pass
----
# 测试:
assert b'abcd' == safe_base64_decode(b'YWJjZA=='), safe_base64_decode('YWJjZA==')
assert b'abcd' == safe_base64_decode(b'YWJjZA'), safe_base64_decode('YWJjZA')
print('Pass')

参考源码
None
<br><br><br>struct<br>============
准确地讲，Python没有专门处理字节的数据类型。但由于
在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的
None
非常麻烦。如果换成浮点数就无能为力了。
好在Python提供了一个
None
None
None
None
后面的参数个数要和处理指令一致。
None
None
根据
所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用
None
None
Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用
首先找一个bmp文件，没有的话用“画图”画一个。
读入前30个字节来分析：
None
BMP格式采用小端方式存储数据，文件头的结构按顺序如下：
两个字节：
所以，组合起来用
None
结果显示，
请编写一个
参考源码
None
<br><br><br>hashlib<br>============
摘要算法简介
Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。
什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。
举个例子，你写了一篇文章，内容是一个字符串
可见，摘要算法就是通过摘要函数
摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算
我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：
None
计算结果如下：
None
如果数据量很大，可以分块多次调用
None
试试改动一个字母，看看计算的结果是否完全不同。
MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。
另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：
None
SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。
比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。
有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能，因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞，比如Bob试图根据你的摘要反推出一篇文章
摘要算法应用
摘要算法能应用到什么地方？举个常用例子：
任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：
None
如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。
正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：
None
当用户登录时，首先计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。
练习
根据用户输入的口令，计算出存储在数据库中的MD5口令：
None
存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。
设计一个验证用户登录的函数，根据用户输入的口令是否正确，返回True或False：
None
采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。
考虑这么个情况，很多用户喜欢用
None
这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。
对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？
由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：
None
经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。
但是如果有两个用户都使用了相同的简单口令比如
如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。
练习
根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5：
None
然后，根据修改后的MD5算法实现用户登录的验证：
None
小结
摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。
参考源码
None
<br><br><br>itertools<br>============
Python的内建模块
首先，我们看看
None
因为
None
None
同样停不下来。
None
None
无限序列只有在
无限序列虽然可以无限迭代下去，但是通常我们会通过
None
None
chain()
None
None
groupby()
None
None
实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素
None
小结
None
参考源码
None
<br><br><br>contextlib<br>============
在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用
None
写
None
并不是只有
实现上下文管理是通过
None
这样我们就可以把自己写的资源对象用于
None
@contextmanager
编写
None
None
None
很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用
None
上述代码执行结果为：
None
代码的执行顺序是：


因此，
@closing
如果一个对象没有实现上下文，我们就不能把它用于
None
None
None
它的作用就是把任意对象变为上下文对象，并支持
None
<br><br><br>XML<br>============
XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。
DOM vs SAX
操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。
正常情况下，优先考虑SAX，因为DOM实在太占内存。
在Python中使用SAX解析XML非常简洁，通常我们关心的事件是
举个例子，当SAX解析器读到一个节点时：
None
会产生3个事件：


用代码实验一下：
None
需要注意的是读取一大段字符串时，
除了解析XML外，如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串：
None
如果要生成复杂的XML呢？建议你不要用XML，改成JSON。
小结
解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。
练习
请利用SAX编写程序解析Yahoo的XML格式的天气预报，获取当天和第二天的天气：
None
参数

# -*- coding:utf-8 -*-

from xml.parsers.expat import ParserCreate
----
class WeatherSaxHandler(object):
    pass

def parse_weather(xml):
    return {
        'city': 'Beijing',
        'country': 'China',
        'today': {
            'text': 'Partly Cloudy',
            'low': 20,
            'high': 33
        },
        'tomorrow': {
            'text': 'Sunny',
            'low': 21,
            'high': 34
        }
    }
----
# 测试:
data = r'''<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<rss version="2.0" xmlns:yweather="http://xml.weather.yahoo.com/ns/rss/1.0" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#">
    <channel>
        <title>Yahoo! Weather - Beijing, CN</title>
        <lastBuildDate>Wed, 27 May 2015 11:00 am CST</lastBuildDate>
        <yweather:location city="Beijing" region="" country="China"/>
        <yweather:units temperature="C" distance="km" pressure="mb" speed="km/h"/>
        <yweather:wind chill="28" direction="180" speed="14.48" />
        <yweather:atmosphere humidity="53" visibility="2.61" pressure="1006.1" rising="0" />
        <yweather:astronomy sunrise="4:51 am" sunset="7:32 pm"/>
        <item>
            <geo:lat>39.91</geo:lat>
            <geo:long>116.39</geo:long>
            <pubDate>Wed, 27 May 2015 11:00 am CST</pubDate>
            <yweather:condition text="Haze" code="21" temp="28" date="Wed, 27 May 2015 11:00 am CST" />
            <yweather:forecast day="Wed" date="27 May 2015" low="20" high="33" text="Partly Cloudy" code="30" />
            <yweather:forecast day="Thu" date="28 May 2015" low="21" high="34" text="Sunny" code="32" />
            <yweather:forecast day="Fri" date="29 May 2015" low="18" high="25" text="AM Showers" code="39" />
            <yweather:forecast day="Sat" date="30 May 2015" low="18" high="32" text="Sunny" code="32" />
            <yweather:forecast day="Sun" date="31 May 2015" low="20" high="37" text="Sunny" code="32" />
        </item>
    </channel>
</rss>
'''
weather = parse_weather(data)
assert weather['city'] == 'Beijing', weather['city']
assert weather['country'] == 'China', weather['country']
assert weather['today']['text'] == 'Partly Cloudy', weather['today']['text']
assert weather['today']['low'] == 20, weather['today']['low']
assert weather['today']['high'] == 33, weather['today']['high']
assert weather['tomorrow']['text'] == 'Sunny', weather['tomorrow']['text']
assert weather['tomorrow']['low'] == 21, weather['tomorrow']['low']
assert weather['tomorrow']['high'] == 34, weather['tomorrow']['high']
print('Weather:', str(weather))

参考源码
None
<br><br><br>HTMLParser<br>============
如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。
假设第一步已经完成了，第二步应该如何解析HTML呢？
HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。
好在Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码：
None
None
特殊字符有两种，一种是英文表示的
小结
利用HTMLParser，可以把网页中的文本、图像等解析出来。
练习
找一个网页，例如
参考源码
None
<br><br><br>urllib<br>============
urllib提供了一系列用于操作URL的功能。
Get
urllib的
例如，对豆瓣的一个URL
None
可以看到HTTP响应的头和JSON数据：
None
如果我们要想模拟浏览器发送GET请求，就需要使用
None
这样豆瓣会返回适合iPhone的移动版网页：
None
Post
如果要以POST发送一个请求，只需要把参数
我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以
None
如果登录成功，我们获得的响应如下：
None
如果登录失败，我们获得的响应如下：
None
Handler
如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用
None
小结
urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，
练习
利用urllib读取XML，将XML一节的数据由硬编码改为由urllib获取：

from urllib import request, parse

def fetch_xml(url):
----
    pass
----
# 测试
print(fetch_xml('http://weather.yahooapis.com/forecastrss?u=c&w=2151330'))

参考源码
None
<br><br><br>常用第三方模块<br>============
除了内建的模块外，Python还有大量的第三方模块。
基本上，所有的第三方模块都会在
本章介绍常用的第三方模块。
<br><br><br>PIL<br>============
PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。
由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫
安装Pillow
在命令行下直接通过pip安装：
None
如果遇到
操作图像
来看看最常见的图像缩放操作，只需三四行代码：
None
其他功能如切片、旋转、滤镜、输出文字、调色板等一应俱全。
比如，模糊效果也只需几行代码：
None
效果如下：
None
PIL的
None
我们用随机颜色填充背景，再画上文字，最后对图像进行模糊，得到验证码图片如下：
None
如果运行的时候报错：
None
这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：
None
要详细了解PIL的强大功能，请请参考Pillow官方文档：
None
小结
PIL提供了操作图像的强大功能，可以通过简单的代码完成复杂的图像处理。
参考源码
None
None
None
<br><br><br>virtualenv<br>============
在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被
如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？
这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。
首先，我们用
None
然后，假定我们要开发一个新的项目，需要一套独立的Python运行环境，可以这么做：
第一步，创建目录：
None
第二步，创建一个独立的Python运行环境，命名为
None
命令
新建的Python环境被放到当前目录下的
None
注意到命令提示符变了，有个
下面正常安装各种第三方包，并运行
None
在
退出当前的
None
此时就回到了正常的环境，现在
完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。
virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令
小结
virtualenv为应用提供了隔离的Python运行环境，解决了不同应用间多版本的冲突问题。
<br><br><br>图形界面<br>============
Python支持多种图形界面的第三方库，包括：


等等。
但是Python自带的库是支持Tk的Tkinter，使用Tkinter，无需安装任何包，就可以直接使用。本章简单介绍如何使用Tkinter进行GUI编程。
Tkinter
我们来梳理一下概念：
我们编写的Python代码会调用内置的Tkinter，Tkinter封装了访问Tk的接口；
Tk是一个图形库，支持多个操作系统，使用Tcl语言开发；
Tk会调用操作系统提供的本地GUI接口，完成最终的GUI。
所以，我们的代码只需要调用Tkinter提供的接口就可以了。
第一个GUI程序
使用Tkinter十分简单，我们来编写一个GUI版本的“Hello, world!”。
第一步是导入Tkinter包的所有内容：
None
第二步是从
None
在GUI中，每个Button、Label、输入框等，都是一个Widget。Frame则是可以容纳其他Widget的Widget，所有的Widget组合起来就是一棵树。
None
在
第三步，实例化
None
GUI程序的主线程负责监听来自操作系统的消息，并依次处理每一条消息。因此，如果消息处理非常耗时，就需要在新线程中处理。
运行这个GUI程序，可以看到下面的窗口：
None
点击“Quit”按钮或者窗口的“x”结束程序。
输入文本
我们再对这个GUI程序改进一下，加入一个文本框，让用户可以输入文本，然后点按钮后，弹出消息对话框。
None
当用户点击按钮时，触发
程序运行结果如下：
None
小结
Python内置的Tkinter可以满足基本的GUI程序的要求，如果是非常复杂的GUI程序，建议用操作系统原生支持的语言和库来编写。
参考源码
None
<br><br><br>网络编程<br>============
自从互联网诞生以来，现在基本上所有的程序都是网络程序，很少有单机版的程序了。
计算机网络就是把各个计算机连接到一起，让网络中的计算机可以互相通信。网络编程就是如何在程序中实现两台计算机的通信。
举个例子，当你使用浏览器访问新浪网时，你的计算机就和新浪的某台服务器通过互联网连接起来了，然后，新浪的服务器把网页内容作为数据通过互联网传输到你的电脑上。
由于你的电脑上可能不止浏览器，还有QQ、Skype、Dropbox、邮件客户端等，不同的程序连接的别的计算机也会不同，所以，更确切地说，网络通信是两台计算机上的两个进程之间的通信。比如，浏览器进程和新浪服务器上的某个Web服务进程在通信，而QQ进程是和腾讯的某个服务器上的某个进程在通信。
None
网络编程对所有开发语言都是一样的，Python也不例外。用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。
本章我们将详细介绍Python网络编程的概念和最主要的两种网络类型的编程。
<br><br><br>TCP/IP简介<br>============
虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多。
计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。
为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。Internet是由inter和net两个单词组合起来的，原意就是连接“网络”的网络，有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网。
因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议。
通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。互联网上每个计算机的唯一标识就是IP地址，类似
IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。
None
IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如
IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于
TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。
许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。
一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。
端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个IP包来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。
一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。
了解了TCP/IP协议的基本概念，IP地址和端口的概念，我们就可以开始进行网络编程了。
<br><br><br>TCP编程<br>============
Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。
客户端
大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。
举个例子，当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了。
所以，我们要创建一个基于TCP连接的Socket，可以这样做：
None
创建
客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名
答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在
因此，我们连接新浪服务器的代码如下：
None
注意参数是一个
建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：
None
TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。
发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：
None
接收数据时，调用
当我们接收完数据后，调用
None
接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：
None
现在，只需要在浏览器中打开这个
服务器
和客户端编程相比，服务器编程就要复杂一些。
服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。
所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。
但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。
我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上
首先，创建一个基于IPv4和TCP协议的Socket：
None
然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用
端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用
None
紧接着，调用
None
接下来，服务器程序通过一个永久循环来接受来自客户端的连接，
None
每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：
None
连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上
要测试这个服务器程序，我们还需要编写一个客户端程序：
None
我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了：
None
需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。
小结
用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。
同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。
参考源码
None
<br><br><br>UDP编程<br>============
TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。
使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。
虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。
我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：
None
创建Socket时，
None
None
注意这里省掉了多线程，因为这个例子很简单。
客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用
None
从服务器接收数据仍然调用
仍然用两个命令行分别启动服务器和客户端测试，结果如下：
None
小结
UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。
参考源码
None
None
<br><br><br>电子邮件<br>============
Email的历史比Web还要久远，直到现在，Email也是互联网上应用非常广泛的服务。
几乎所有的编程语言都支持发送和接收电子邮件，但是，先等等，在我们开始编写代码之前，有必要搞清楚电子邮件是如何在互联网上运作的。
我们来看看传统邮件是如何运作的。假设你现在在北京，要给一个香港的朋友发一封信，怎么做呢？
首先你得写好信，装进信封，写上地址，贴上邮票，然后就近找个邮局，把信仍进去。
信件会从就近的小邮局转运到大邮局，再从大邮局往别的城市发，比如先发到天津，再走海运到达香港，也可能走京九线到香港，但是你不用关心具体路线，你只需要知道一件事，就是信件走得很慢，至少要几天时间。
信件到达香港的某个邮局，也不会直接送到朋友的家里，因为邮局的叔叔是很聪明的，他怕你的朋友不在家，一趟一趟地白跑，所以，信件会投递到你的朋友的邮箱里，邮箱可能在公寓的一层，或者家门口，直到你的朋友回家的时候检查邮箱，发现信件后，就可以取到邮件了。
电子邮件的流程基本上也是按上面的方式运作的，只不过速度不是按天算，而是按秒算。
现在我们回到电子邮件，假设我们自己的电子邮件地址是
Email从MUA发出去，不是直接到达对方电脑，而是发到
Email到达新浪的MTA后，由于对方使用的是
同普通邮件类似，Email不会直接到达对方的电脑，因为对方电脑不一定开机，开机也不一定联网。对方要取到邮件，必须通过MUA从MDA上把邮件取到自己的电脑上。
所以，一封电子邮件的旅程就是：
None
有了上述基本概念，要编写程序来发送和接收邮件，本质上就是：


发邮件时，MUA和MTA使用的协议就是SMTP：Simple Mail Transfer Protocol，后面的MTA到另一个MTA也是用SMTP协议。
收邮件时，MUA和MDA使用的协议有两种：POP：Post Office Protocol，目前版本是3，俗称POP3；IMAP：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱，等等。
邮件客户端软件在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。假设你正在使用163的邮箱，你就不能直接发到新浪的MTA上，因为它只服务新浪的用户，所以，你得填163提供的SMTP服务器地址：
类似的，从MDA收邮件时，MDA服务器也要求验证你的邮箱口令，确保不会有人冒充你收取你的邮件，所以，Outlook之类的邮件客户端会要求你填写POP3或IMAP服务器地址、邮箱地址和口令，这样，MUA才能顺利地通过POP或IMAP协议从MDA取到邮件。
在使用Python收发邮件前，请先准备好至少两个电子邮件，如
最后
None
<br><br><br>SMTP发送邮件<br>============
SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。
Python对SMTP支持有
首先，我们来构造一个最简单的纯文本邮件：
None
注意到构造
然后，通过SMTP发出去：
None
我们用
如果一切顺利，就可以在收件人信箱中收到我们刚发送的Email：
None
仔细观察，发现如下问题：


这是因为邮件主题、如何显示发件人、收件人等信息并不是通过SMTP协议发给MTA，而是包含在发给MTA的文本中的，所以，我们必须把
None
我们编写了一个函数
None
再发送一遍邮件，就可以在收件人邮箱中看到正确的标题、发件人和收件人：
None
你看到的收件人的名字很可能不是我们传入的
如果我们查看Email的原始内容，可以看到如下经过编码的邮件头：
None
这就是经过
发送HTML邮件
如果我们要发送HTML邮件，而不是普通的纯文本文件怎么办？方法很简单，在构造
None
再发送一遍邮件，你将看到以HTML显示的邮件：
None
发送附件
如果Email中要加上附件怎么办？带附件的邮件可以看做包含若干部分的邮件：文本和各个附件本身，所以，可以构造一个
None
然后，按正常发送流程把
None
发送图片
如果要把一个图片嵌入到邮件正文中怎么做？直接在HTML邮件中链接图片地址行不行？答案是，大部分邮件服务商都会自动屏蔽带有外链的图片，因为不知道这些链接是否指向恶意网站。
要把图片嵌入到邮件正文中，我们只需按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用
把上面代码加入
None
再次发送，就可以看到图片直接嵌入到邮件正文的效果：
None
同时支持HTML和Plain格式
如果我们发送HTML邮件，收件人通过浏览器或者Outlook之类的软件是可以正常浏览邮件内容的，但是，如果收件人使用的设备太古老，查看不了HTML邮件怎么办？
办法是在发送HTML的同时再附加一个纯文本，如果收件人无法查看HTML格式的邮件，就可以自动降级查看纯文本邮件。
利用
None
加密SMTP
使用标准的25端口连接SMTP服务器时，使用的是明文传输，发送邮件的整个过程可能会被窃听。要更安全地发送邮件，可以加密SMTP会话，实际上就是先创建SSL安全连接，然后再使用SMTP协议发送邮件。
某些邮件服务商，例如Gmail，提供的SMTP服务必须要加密传输。我们来看看如何通过Gmail提供的安全SMTP发送邮件。
必须知道，Gmail的SMTP端口是587，因此，修改代码如下：
None
只需要在创建
如果因为网络问题无法连接Gmail的SMTP服务器，请相信我们的代码是没有问题的，你需要对你的网络设置做必要的调整。
小结
使用Python的smtplib发送邮件十分简单，只要掌握了各种邮件类型的构造方法，正确设置好邮件头，就可以顺利发出。
构造一个邮件对象就是一个
None
这种嵌套关系就可以构造出任意复杂的邮件。你可以通过
参考源码
None
<br><br><br>POP3收取邮件<br>============
SMTP用于发送邮件，如果要收取邮件呢？
收取邮件就是编写一个
Python内置一个
注意到POP3协议收取的不是一个已经可以阅读的邮件本身，而是邮件的原始文本，这和SMTP协议很像，SMTP发送的也是经过编码后的一大段文本。
要把POP3收取的文本变成可以阅读的邮件，还需要用
所以，收取邮件分两步：
第一步：用
第二部：用
通过POP3下载邮件
POP3协议本身很简单，以下面的代码为例，我们来获取最新的一封邮件内容：
None
用POP3获取邮件其实很简单，要获取所有邮件，只需要循环使用
解析邮件
解析邮件的过程和上一节构造邮件正好相反，因此，先导入必要的模块：
None
只需要一行代码就可以把邮件内容解析为
None
但是这个
所以我们要递归地打印出
None
邮件的Subject或者Email中包含的名字都是经过编码后的str，要正常显示，就必须decode：
None
None
文本邮件的内容也是str，还需要检测编码，否则，非UTF-8编码的邮件都无法正常显示：
None
把上面的代码整理好，我们就可以来试试收取一封邮件。先往自己的邮箱发一封邮件，然后用浏览器登录邮箱，看看邮件收到没，如果收到了，我们就来用Python程序把它收到本地：
None
运行程序，结果如下：
None
我们从打印的结构可以看出，这封邮件是一个
小结
用Python的
参考源码
None
<br><br><br>访问数据库<br>============
程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。
而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：


你可以用一个文本文件保存，一行保存一个学生，用
None
你还可以用JSON格式保存，也是文本文件：
None
你还可以定义各种保存格式，但是问题来了：
存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；
不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存（比如蓝光电影，40GB的数据），根本无法全部读入内存。
为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。
数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。
关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：
假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来：
None
每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格：
None
这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级：
None
也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。
根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：
None
结果也是一个表：
None
类似的，Class表的一行记录又可以关联到Student表的多行记录：
None
由于本教程不涉及到关系数据库的详细内容，如果你想从零学习关系数据库和基本的SQL语句，如果你想从零学习关系数据库和基本的SQL语句，请自行搜索相关课程。
NoSQL
你也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被他们忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？
数据库类别
既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：
付费的商用数据库：


这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：


作为Python开发工程师，选择哪个免费数据库呢？当然是MySQL。因为MySQL普及率最高，出了错，可以很容易找到解决方法。而且，围绕MySQL有一大堆监控和运维的工具，安装和使用很方便。
为了能继续后面的学习，你需要从MySQL官方网站下载并安装
<br><br><br>使用SQLite<br>============
SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。
Python就内置了SQLite3，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。
在使用SQLite前，我们先要搞清楚几个概念：
表是数据库中存放关系数据的集合，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。表和表之间通过外键关联。
要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；
连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。
Python定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。
由于SQLite的驱动内置在Python标准库中，所以我们可以直接来操作SQLite数据库。
我们在Python交互式命令行实践一下：
None
我们再试试查询记录：
None
使用Python的DB-API时，只要搞清楚
使用
使用
如果SQL语句带有参数，那么需要把参数按照位置传递给
None
SQLite支持常见的标准SQL语句以及几种常见的数据类型。具体文档请参阅SQLite官方网站。
小结
在Python中操作数据库时，要先导入数据库对应的驱动，然后，通过
要确保打开的
如何才能确保出错的情况下也关闭掉
练习
请编写函数，在Sqlite中根据分数段查找指定的名字：

# -*- coding: utf-8 -*-

import os, sqlite3

db_file = os.path.join(os.path.dirname(__file__), 'test.db')
if os.path.isfile(db_file):
    os.remove(db_file)

# 初始数据:
conn = sqlite3.connect(db_file)
cursor = conn.cursor()
cursor.execute('create table user(id varchar(20) primary key, name varchar(20), score int)')
cursor.execute(r"insert into user values ('A-001', 'Adam', 95)")
cursor.execute(r"insert into user values ('A-002', 'Bart', 62)")
cursor.execute(r"insert into user values ('A-003', 'Lisa', 78)")
cursor.close()
conn.commit()
conn.close()

def get_score_in(low, high):
    ' 返回指定分数区间的名字，按分数从低到高排序 '
----
    pass
----
# 测试:
assert get_score_in(80, 95) == ['Adam'], get_score_in(80, 95)
assert get_score_in(60, 80) == ['Bart', 'Lisa'], get_score_in(60, 80)
assert get_score_in(60, 100) == ['Bart', 'Lisa', 'Adam'], get_score_in(60, 100)

print('Pass')

参考源码
None
<br><br><br>使用MySQL<br>============
MySQL是Web世界中使用最广泛的数据库服务器。SQLite的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用。而MySQL是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于SQLite。
此外，MySQL内部有多种数据库引擎，最常用的引擎是支持数据库事务的InnoDB。
安装MySQL
可以直接从MySQL官方网站下载最新的
安装时，MySQL会提示输入
在Windows上，安装时请选择
在Mac或Linux上，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。MySQL的配置文件默认存放在
None
重启MySQL后，可以通过MySQL的客户端命令行检查编码：
None
看到
None
安装MySQL驱动
由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。MySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数
None
如果上面的命令安装失败，可以试试另一个驱动：
None
我们演示如何连接到MySQL服务器的test数据库：
None
由于Python的DB-API定义都是通用的，所以，操作MySQL的数据库代码和SQLite类似。
小结


参考源码
None
<br><br><br>使用SQLAlchemy<br>============
数据库表是一个二维表，包含多行多列。把一个表的内容用Python的数据结构表示出来的话，可以用一个list表示多行，list的每一个元素是tuple，表示一行记录，比如，包含
None
Python的DB-API返回的数据结构就是像上面这样表示的。
但是用tuple表示一行很难看出表的结构。如果把一个tuple用class实例来表示，就可以更容易地看出表的结构来：
None
这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。是不是很简单？
但是由谁来做这个转换呢？所以ORM框架应运而生。
在Python中，最有名的ORM框架是SQLAlchemy。我们来看看SQLAlchemy的用法。
首先通过pip安装SQLAlchemy：
None
然后，利用上次我们在MySQL的test数据库中创建的
第一步，导入SQLAlchemy，并初始化DBSession：
None
以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如School：
None
None
None
你只需要根据需要替换掉用户名、口令等信息即可。
下面，我们看看如何向数据库表中添加一行记录。
由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个
None
可见，关键是获取session，然后把对象添加到session，最后提交并关闭。
如何从数据库表中查询数据呢？有了ORM，查询出来的可以不再是tuple，而是
None
运行结果如下：
None
可见，ORM就是把数据库表的行与相应的对象建立关联，互相转换。
由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。
例如，如果一个User拥有多个Book，就可以定义一对多关系如下：
None
当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。
小结
ORM框架的作用就是把数据库表的一行记录与一个对象互相做自动转换。
正确使用ORM的前提是了解关系数据库的原理。
参考源码
None
<br><br><br>Web开发<br>============
最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种Client/Server模式简称CS架构。
随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。
在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。
当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构迅速流行起来。
今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。
Web应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：


目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。
Python的诞生历史比Web还要早，由于Python是一种解释型的脚本语言，开发效率高，所以非常适合用来做Web开发。
Python有上百种Web开发框架，有很多成熟的模板技术，选择Python开发Web应用，不但开发效率高，而且运行速度快。
本章我们会详细讨论Python Web开发技术。
<br><br><br>HTTP协议简介<br>============
在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP，所以：


在举例子之前，我们需要安装Google的
为什么要使用Chrome浏览器而不是IE呢？因为IE实在是太慢了，并且，IE对于开发和调试Web应用程序完全是一点用也没有。
我们需要在浏览器很方便地调试我们的Web应用，而Chrome提供了一套完整地调试工具，非常适合Web开发。
安装好Chrome浏览器后，打开Chrome，在菜单中选择“视图”，“开发者”，“开发者工具”，就可以显示开发者工具：
None
None
None
当我们在地址栏输入
None
最主要的头两行分析如下，第一行：
None
None
从第二行开始，每一行都类似于
None
表示请求的域名是
继续往下找到
None
HTTP响应分为Header和Body两部分（Body是可选项），我们在
None
None
None
None
HTTP响应的Body就是HTML源码，我们在菜单栏选择“视图”，“开发者”，“查看网页源码”就可以在浏览器中直接查看HTML源码：
None
当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在
HTTP请求
跟踪了新浪的首页，我们来总结一下HTTP请求的流程：
步骤1：浏览器首先向服务器发送HTTP请求，请求包括：
方法：GET还是POST，GET仅请求资源，POST会附带用户数据；
路径：/full/url/path；
域名：由Host头指定：Host: www.sina.com.cn
以及其他相关的Header；
如果是POST，那么请求还包括一个Body，包含用户数据。
步骤2：服务器向浏览器返回HTTP响应，响应包括：
响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；
响应类型：由Content-Type指定；
以及其他相关的Header；
通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。
步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。
Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，一个HTTP请求只处理一个资源。
HTTP协议同时具备极强的扩展性，虽然浏览器请求的是
HTTP格式
每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。
HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：
None
每个Header一行一个，换行符是
HTTP POST请求的格式：
None
当遇到连续两个
HTTP响应的格式：
None
HTTP响应如果包含body，也是通过
当存在
要详细了解HTTP协议，推荐“
None
<br><br><br>HTML简介<br>============
网页就是HTML？这么理解大概没错。因为网页中不但包含文字，还有图片、视频、Flash小游戏，有复杂的排版、动画效果，所以，HTML定义了一套语法规则，来告诉浏览器如何把一个丰富多彩的页面显示出来。
HTML长什么样？上次我们看了新浪首页的HTML源码，如果仔细数数，竟然有6000多行！
所以，学HTML，就不要指望从新浪入手了。我们来看看最简单的HTML长什么样：
None
可以用文本编辑器编写HTML，然后保存为
None
HTML文档就是一系列的Tag组成，最外层的Tag是
CSS简介
CSS是Cascading Style Sheets（层叠样式表）的简称，CSS用来控制HTML里的所有元素如何展现，比如，给标题元素
None
效果如下：
None
JavaScript简介
JavaScript虽然名称有个Java，但它和Java真的一点关系没有。JavaScript是为了让HTML具有交互性而作为脚本语言添加的，JavaScript既可以内嵌到HTML中，也可以从外部链接到HTML中。如果我们希望当用户点击标题时把标题变成红色，就必须通过JavaScript来实现：
None
点击标题后效果如下：
None
小结
如果要学习Web开发，首先要对HTML、CSS和JavaScript作一定的了解。HTML定义了页面的内容，CSS来控制页面元素的样式，而JavaScript负责页面的交互逻辑。
讲解HTML、CSS和JavaScript就可以写3本书，对于优秀的Web开发人员来说，精通HTML、CSS和JavaScript是必须的，这里推荐一个在线学习网站w3schools：
None
以及一个对应的中文版本：
None
当我们用Python或者其他语言开发Web应用时，我们就是要在服务器端动态创建出HTML，这样，浏览器就会向不同的用户显示出不同的Web页面。
<br><br><br>WSGI接口<br>============
了解了HTTP协议和HTML文档，我们其实就明白了一个Web应用的本质就是：


所以，最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的。
如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。
正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口，让我们专心用Python编写Web业务。
这个接口就是WSGI：Web Server Gateway Interface。
WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：
None
上面的


在
None
就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次
通常情况下，都应该把
然后，函数的返回值
有了WSGI，我们关心的就是如何从
整个
不过，等等，这个
所以
好消息是Python内置了一个WSGI服务器，这个模块叫wsgiref，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。
运行WSGI服务
我们先编写
None
然后，再编写一个
None
确保以上两个文件在同一个目录下，然后在命令行输入
None
注意：如果
启动成功后，打开浏览器，输入
None
在命令行可以看到wsgiref打印的log信息：
None
按
如果你觉得这个Web应用太简单了，可以稍微改造一下，从
None
你可以在地址栏输入用户名作为URL的一部分，将返回
None
是不是有点Web App的感觉了？
小结
无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过
复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。
参考源码
None
None
<br><br><br>使用Web框架<br>============
了解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。
但是如何处理HTTP请求不是问题，问题是如何处理100个不同的URL。
每一个URL可以对应GET和POST请求，当然还有PUT、DELETE等请求，但是我们通常只考虑最常见的GET和POST请求。
一个最简单的想法是从
None
只是这么写下去代码是肯定没法维护了。
代码这么写没法维护的原因是因为WSGI提供的接口虽然比HTTP接口高级了不少，但和Web App的处理逻辑比，还是比较低级，我们需要在WSGI接口之上能进一步抽象，让我们专注于用一个函数处理一个URL，至于URL到函数的映射，就交给Web框架来做。
由于用Python开发一个Web框架十分容易，所以Python有上百个开源的Web框架。这里我们先不讨论各种Web框架的优缺点，直接选择一个比较流行的Web框架——
用Flask编写Web App比WSGI接口简单（这不是废话么，要是比WSGI还复杂，用框架干嘛？），我们先用
None
然后写一个


注意噢，同一个URL
Flask通过Python的
None
运行
None
打开浏览器，输入首页地址
None
首页显示正确！
再在浏览器地址栏输入
None
输入预设的用户名
None
输入其他错误的用户名和口令，登录失败：
None
实际的Web App应该拿到用户名和口令后，去数据库查询再比对，来判断用户是否能登录成功。
除了Flask，常见的Python Web框架还有：


当然了，因为开发Python的Web框架也不是什么难事，我们后面也会讲到开发Web框架的内容。
小结
有了Web框架，我们在编写Web应用时，注意力就从WSGI处理函数转移到URL+对应的处理函数，这样，编写Web App就更加简单了。
在编写URL处理函数时，除了配置URL外，从HTTP请求拿到用户数据也是非常重要的。Web框架都提供了自己的API来实现这些功能。Flask通过
参考源码
None
<br><br><br>使用模板<br>============
Web框架把我们从WSGI中拯救出来了。现在，我们只需要不断地编写函数，带上URL，就可以继续Web App的开发了。
但是，Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串，简单的页面还可以，但是，想想新浪首页的6000多行的HTML，你确信能在Python的字符串中正确地写出来么？反正我是做不到。
俗话说得好，不懂前端的Python工程师不是好的产品经理。有Web开发经验的同学都明白，Web App最复杂的部分就在HTML页面。HTML不仅要正确，还要通过CSS美化，再加上复杂的JavaScript脚本来实现各种交互和动画效果。总之，生成HTML页面的难度很大。
由于在Python代码里拼字符串是不现实的，所以，模板技术出现了。
使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户：
None
这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。
Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；
包含变量
MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。
上面的例子中，Model就是一个
None
只是因为Python支持关键字参数，很多Web框架允许传入关键字参数，然后，在框架内部组装出一个
现在，我们把上次直接输出字符串作为HTML的例子用高端大气上档次的MVC模式改写一下：
None
Flask通过
None
然后，开始编写jinja2模板：
home.html
用来显示首页的模板：
None
form.html
用来显示登录表单的模板：
None
signin-ok.html
登录成功的模板：
None
登录失败的模板呢？我们在
最后，一定要把模板放到正确的
None
启动
None
通过MVC，我们在Python代码中处理M：Model和C：Controller，而V：View是通过模板处理的，这样，我们就成功地把Python代码和HTML代码最大限度地分离了。
使用模板的另一大好处是，模板改起来很方便，而且，改完保存后，刷新浏览器就能看到最新的效果，这对于调试HTML、CSS和JavaScript的前端工程师来说实在是太重要了。
在Jinja2模板中，我们用
比如循环输出页码：
None
如果
除了Jinja2，常见的模板还有：


小结
有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。
源码参考
None
<br><br><br>异步IO<br>============
在IO编程一节中，我们已经知道，CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。
在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。
因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。
多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。
由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。
另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。
可以想象如果按普通顺序写出的代码实际上是没法完成异步IO的：
None
所以，同步IO模型的代码是无法实现异步IO模型的。
异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程：
None
消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。
由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。
消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。
在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。
<br><br><br>协程<br>============
在学习异步IO模型前，我们先来了解协程。
协程，又称微线程，纤程。英文名Coroutine。
协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。
子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。
所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。
子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。
协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：
None
假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：
None
但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。
看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？
最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。
因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
Python对协程的支持是通过generator实现的。
在generator中，我们不但可以通过
但是Python的
来看例子：
传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。
如果改用协程，生产者生产消息后，直接通过
None
执行结果：
None
注意到


整个流程无锁，由一个线程执行，
最后套用Donald Knuth的一句话总结协程的特点：
“子程序就是协程的一种特例。”
参考源码
None
<br><br><br>asyncio<br>============
None
None
用
None
None
None
把
我们用Task封装两个
None
观察执行过程：
None
由打印的当前线程名称可以看出，两个
如果把
我们用
None
执行结果如下：
None
可见3个连接由一个线程通过
小结
None
异步操作需要在
多个
参考源码
None
None
<br><br><br>async/await<br>============
用
为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法
请注意，


让我们对比一下上一节的代码：
None
用新语法重新编写如下：
None
剩下的代码保持不变。
小结
Python从3.5版本开始为
注意新语法只能用在Python 3.5以及后续版本，如果使用3.4版本，则仍需使用上一节的方案。
练习
将上一节的异步获取sina、sohu和163的网站首页源码用新语法重写并运行。
参考源码
None
None
<br><br><br>aiohttp<br>============
None
None
我们先安装
None
然后编写一个HTTP服务器，分别处理以下URL：


代码如下：
None
注意
参考源码
None
<br><br><br>实战<br>============
看完了教程，是不是有这么一种感觉：看的时候觉得很简单，照着教程敲代码也没啥大问题。
于是准备开始独立写代码，就发现不知道从哪开始下手了。
这种情况是完全正常的。好比学写作文，学的时候觉得简单，写的时候就无从下笔了。
虽然这个教程是面向小白的零基础Python教程，但是我们的目标不是学到60分，而是学到90分。
所以，用Python写一个真正的Web App吧！
目标
我们设定的实战目标是一个Blog网站，包含日志、用户和评论3大部分。
很多童鞋会想，这是不是太简单了？
比如
但是，这样的页面：
None
你拿得出手么？
我们要写出用户真正看得上眼的页面，首页长得像这样：
None
评论区：
None
还有极其强大的后台管理页面：
None
是不是一下子变得高端大气上档次了？
项目名称
必须是高端大气上档次的名称，命名为
项目计划
项目计划开发周期为16天。每天，你需要完成教程中的内容。如果你觉得编写代码难度实在太大，可以参考一下当天在GitHub上的代码。
第N天的代码在
None
以此类推。
要预览
None
<br><br><br>Day 1 - 搭建开发环境<br>============
搭建开发环境
首先，确认系统安装的Python版本是3.5.x：
None
然后，用
异步框架aiohttp：
None
前端模板引擎jinja2：
None
MySQL 5.x数据库，从
MySQL的Python异步驱动程序aiomysql：
None
项目结构
选择一个工作目录，然后，我们建立如下的目录结构：
None
创建好项目的目录结构后，建议同时建立git仓库并同步至GitHub，保证代码修改的安全。
要了解git和GitHub的用法，请移步
开发工具
自备，推荐用Sublime Text，请参考
参考源码
None
<br><br><br>Day 2 - 编写Web App骨架<br>============
由于我们的Web App建立在asyncio的基础上，因此用aiohttp写一个基本的
None
运行
None
这里我们简单地返回一个
None
这说明我们的Web App骨架已经搭好了，可以进一步往里面添加更多的东西。
参考源码
None
<br><br><br>Day 3 - 编写ORM<br>============
在一个Web App中，所有数据，包括用户信息、发布的日志、评论等，都存储在数据库中。在awesome-python3-webapp中，我们选择MySQL作为数据库。
Web App里面有很多地方都要访问数据库。访问数据库需要创建数据库连接、游标对象，然后执行SQL语句，最后处理异常，清理资源。这些访问数据库的代码如果分散到各个函数中，势必无法维护，也不利于代码复用。
所以，我们要首先把常用的SELECT、INSERT、UPDATE和DELETE操作用函数封装起来。
由于Web框架使用了基于asyncio的aiohttp，这是基于协程的异步模型。在协程中，不能调用普通的同步IO操作，因为所有用户都是由一个线程服务的，协程的执行速度必须非常快，才能处理大量用户的请求。而耗时的IO操作不能在协程中以同步的方式调用，否则，等待一个IO操作时，系统无法响应任何其他用户。
这就是异步编程的一个原则：一旦决定使用异步，则系统每一层都必须是异步，“开弓没有回头箭”。
幸运的是
创建连接池
我们需要创建一个全局的连接池，每个HTTP请求都可以从连接池中直接获取数据库连接。使用连接池的好处是不必频繁地打开和关闭数据库连接，而是能复用就尽量复用。
连接池由全局变量
None
Select
要执行SELECT语句，我们用
None
SQL语句的占位符是
注意到
如果传入
Insert, Update, Delete
要执行INSERT、UPDATE、DELETE语句，可以定义一个通用的
None
None
ORM
有了基本的
设计ORM需要从上层调用者角度来设计。
我们先考虑如何定义一个
None
注意到定义在
None
定义Model
首先要定义的是所有ORM映射的基类
None
None
None
以及
None
映射
None
注意到
None
这样，任何继承自Model的类（比如User），会自动通过ModelMetaclass扫描映射关系，并存储到自身的类属性如
然后，我们往Model类添加class方法，就可以让所有子类调用class方法：
None
User类现在就可以通过类方法实现主键查找：
None
往Model类添加实例方法，就可以让所有子类调用实例方法：
None
这样，就可以把一个User实例存入数据库：
None
最后一步是完善ORM，对于查找，我们可以实现以下方法：


以及
所有这些方法都必须用
调用时需要特别注意：
None
没有任何效果，因为调用
None
才真正执行了INSERT操作。
最后看看我们实现的ORM模块一共多少行代码？累计不到300多行。用Python写一个ORM是不是很容易呢？
参考源码
None
<br><br><br>Day 4 - 编写Model<br>============
有了ORM，我们就可以把Web App需要的3个表用
None
在编写ORM时，给一个Field增加一个
例如，主键
日期和时间用
初始化数据库表
如果表的数量很少，可以手写创建表的SQL脚本：
None
如果表的数量很多，可以从
把SQL脚本放到MySQL命令行里执行：
None
我们就完成了数据库表的初始化。
编写数据访问代码
接下来，就可以真正开始编写代码操作对象了。比如，对于
None
可以在MySQL客户端命令行查询，看看数据是不是正常存储到MySQL里面了。
参考源码
None
<br><br><br>Day 5 - 编写Web框架<br>============
在正式开始Web开发前，我们需要编写一个Web框架。
None
原因是从使用者的角度来说，
第一步，编写一个用
None
第二步，传入的参数需要自己从
None
最后，需要自己构造
None
这些重复的工作可以由框架完成。例如，处理带参数的URL
None
处理
None
对于函数的返回值，不一定是
如果希望渲染模板，我们可以这么返回一个
None
因此，Web框架的设计是完全从使用者出发，目的是让使用者编写尽可能少的代码。
编写简单的函数而非引入
@get和@post
要把一个函数映射为一个URL处理函数，我们先定义
None
这样，一个函数通过
None
定义RequestHandler
URL处理函数不一定是一个
None
None
None
再编写一个
None
最后一步，把很多次
None
变成自动扫描：
None
None
None
最后，在
None
middleware
None
一个
None
而
None
有了这些基础设施，我们就可以专注地往
参考源码
None
<br><br><br>Day 6 - 编写配置文件<br>============
有了Web框架和ORM框架，我们就可以开始装配App了。
通常，一个Web App在运行时都需要读取配置文件，比如数据库的用户名、口令等，在不同的环境中运行时，Web App可以通过读取不同的配置文件来获得正确的配置。
由于Python本身语法简单，完全可以直接用Python源代码来实现配置，而不需要再解析一个单独的
默认的配置文件应该完全符合本地开发环境，这样，无需任何设置，就可以立刻启动服务器。
我们把默认的配置文件命名为
None
上述配置文件简单明了。但是，如果要部署到服务器时，通常需要修改数据库的host等信息，直接修改
None
把
应用程序读取配置文件需要优先从
None
这样，我们就完成了App的配置。
参考源码
None
<br><br><br>Day 7 - 编写MVC<br>============
现在，ORM框架、Web框架和配置都已就绪，我们可以开始编写一个最简单的MVC，把它们全部启动起来。
通过Web框架的
None
None
None
接下来，如果一切顺利，可以用命令行启动Web服务器：
None
然后，在浏览器中访问
如果数据库的
None
参考源码
None
<br><br><br>Day 8 - 构建前端<br>============
虽然我们跑通了一个最简单的MVC，但是页面效果肯定不会让人满意。
对于复杂的HTML前端页面来说，我们需要一套基础的CSS框架来完成页面布局和基本样式。另外，jQuery作为操作DOM的JavaScript库也必不可少。
从零开始写CSS不如直接从一个已有的功能完善的CSS框架开始。有很多CSS框架可供选择。我们这次选择
可以从
所有的静态资源文件我们统一放到
None
由于前端页面肯定不止首页一个页面，每个页面都有相同的页眉和页脚。如果每个页面都是独立的HTML模板，那么我们在修改页眉和页脚的时候，就需要把每个模板都改一遍，这显然是没有效率的。
常见的模板引擎已经考虑到了页面上重复的HTML部分的复用问题。有的模板通过include把页面拆成三部分：
None
这样，相同的部分
但是include方法不利于页面整体结构的维护。jinjia2的模板还有另一种“继承”方式，实现模板的复用更简单。
“继承”模板的方式是通过编写一个“父模板”，在父模板中定义一些可替换的block（块）。然后，编写多个“子模板”，每个子模板都可以只替换父模板定义的block。比如，定义一个最简单的父模板：
None
对于子模板
None
对于子模板
None
这样，一旦定义好父模板的整体布局和CSS样式，编写子模板就会非常容易。
让我们通过uikit这个CSS框架来完成父模板
None
None
用于子页面定义一些meta，例如rss feed：
None
覆盖页面的标题：
None
子页面可以在
None
子页面的content布局和内容：
None
我们把首页改造一下，从
None
相应地，首页URL的处理函数更新如下：
None
Blog的创建日期显示的是一个浮点数，因为它是由这段模板渲染出来的：
None
解决方法是通过jinja2的filter（过滤器），把一个浮点数转换成日期字符串。我们来编写一个
None
filter需要在初始化jinja2时设置。相关代码如下：
None
现在，完善的首页显示如下：
None
参考源码
None
<br><br><br>Day 9 - 编写API<br>============
自从Roy Fielding博士在2000年他的博士论文中提出
什么是Web API呢？
如果我们想要获取一篇Blog，输入
如果一个URL返回的不是HTML，而是机器能直接解析的数据，这个URL就可以看成是一个Web API。比如，读取
REST就是一种设计API的模式。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。
编写API有什么好处呢？由于API就是把Web App的功能全部封装了，所以，通过API操作数据，可以极大地把前端和后端的代码隔离，使得后端代码易于测试，前端代码编写更简单。
一个API也是一个URL的处理函数，我们希望能直接通过一个
None
只要返回一个
我们需要对Error进行处理，因此定义一个
客户端调用API时，必须通过错误代码来区分API调用是否成功。错误代码是用来告诉调用者出错的原因。很多API用一个整数表示错误码，这种方式很难维护错误码，客户端拿到错误码还需要查表得知错误信息。更好的方式是用字符串表示错误代码，不需要看文档也能猜到错误原因。
可以在浏览器直接测试API，例如，输入
None
参考源码
None
<br><br><br>Day 10 - 用户注册和登录<br>============
用户管理是绝大部分Web网站都需要解决的问题。用户管理涉及到用户注册和登录。
用户注册相对简单，我们可以先通过API把用户注册这个功能实现了：
None
注意用户口令是客户端传递的经过SHA1计算后的40位Hash字符串，所以服务器端并不知道用户的原始口令。
接下来可以创建一个注册页面，让用户填写注册表单，然后，提交数据到注册用户的API：
None
这样我们就把用户注册的功能完成了：
None
用户登录比用户注册复杂。由于HTTP协议是一种无状态协议，而服务器要跟踪用户状态，就只能通过cookie实现。大多数Web框架提供了Session功能来封装保存用户状态的cookie。
Session的优点是简单易用，可以直接从Session中取出用户登录信息。
Session的缺点是服务器需要在内存中维护一个映射表来存储用户登录信息，如果有两台以上服务器，就需要对Session做集群，因此，使用Session的Web App很难扩展。
我们采用直接读取cookie的方式来验证用户登录，每次用户访问任意URL，都会对cookie进行验证，这种方式的好处是保证服务器处理任意的URL都是无状态的，可以扩展到多台服务器。
由于登录成功后是由服务器生成一个cookie发送给浏览器，所以，要保证这个cookie不会被客户端伪造出来。
实现防伪造cookie的关键是通过一个单向算法（例如SHA1），举例如下：
当用户输入了正确的口令登录成功后，服务器可以从数据库取到用户的id，并按照如下方式计算出一个字符串：
None
当浏览器发送cookie到服务器端后，服务器可以拿到的信息包括：


如果未到过期时间，服务器就根据用户id查找用户口令，并计算：
None
并与浏览器cookie中的MD5进行比较，如果相等，则说明用户已登录，否则，cookie就是伪造的。
这个算法的关键在于SHA1是一种单向算法，即可以通过原始字符串计算出SHA1结果，但无法通过SHA1结果反推出原始字符串。
所以登录API可以实现如下：
None
对于每个URL处理函数，如果我们都去写解析cookie的代码，那会导致代码重复很多次。
利用middle在处理URL之前，把cookie解析出来，并将登录用户绑定到
None
这样，我们就完成了用户注册和登录的功能。
参考源码
None
<br><br><br>Day 11 - 编写日志创建页<br>============
在Web开发中，后端代码写起来其实是相当容易的。
例如，我们编写一个REST API，用于创建一个Blog：
None
编写后端Python代码不但很简单，而且非常容易测试，上面的API：
Web开发真正困难的地方在于编写前端页面。前端页面需要混合HTML、CSS和JavaScript，如果对这三者没有深入地掌握，编写的前端页面将很快难以维护。
更大的问题在于，前端页面通常是动态页面，也就是说，前端页面往往是由后端代码生成的。
生成前端页面最早的方式是拼接字符串：
None
显然这种方式完全不具备可维护性。所以有第二种模板方式：
None
ASP、JSP、PHP等都是用这种模板方式生成前端页面。
如果在页面上大量使用JavaScript（事实上大部分页面都会），模板方式仍然会导致JavaScript代码与后端代码绑得非常紧密，以至于难以维护。其根本原因在于负责显示的HTML DOM模型与负责数据和交互的JavaScript代码没有分割清楚。
要编写可维护的前端代码绝非易事。和后端结合的MVC模式已经无法满足复杂页面逻辑的需要了，所以，新的
MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示：
None
View是纯HTML：
None
由于Model表示数据，View负责显示，两者做到了最大限度的分离。
把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。
ViewModel如何编写？需要用JavaScript编写一个通用的ViewModel，这样，就可以复用整个MVVM模型了。
好消息是已有许多成熟的MVVM框架，例如AngularJS，KnockoutJS等。我们选择
None
初始化Vue时，我们指定3个参数：
el：根据选择器查找绑定的View，这里是
data：JavaScript对象表示的Model，我们初始化为
methods：View可以触发的JavaScript函数，
接下来，我们在
None
Form表单通过
需要特别注意的是，在MVVM中，Model和View是双向绑定的。如果我们在Form中修改了文本框的值，可以在Model中立刻拿到新的值。试试在表单中输入文本，然后在Chrome浏览器中打开JavaScript控制台，可以通过
None
如果我们在JavaScript逻辑中修改了Model，这个修改会立刻反映到View上。试试在JavaScript控制台输入
None
双向绑定是MVVM框架最大的作用。借助于MVVM，我们把复杂的显示逻辑交给框架完成。由于后端编写了独立的REST API，所以，前端用AJAX提交表单非常容易，前后端分离得非常彻底。
参考源码
None
<br><br><br>Day 12 - 编写日志列表页<br>============
MVVM模式不但可用于Form表单，在复杂的管理页面中也能大显身手。例如，分页显示Blog的功能，我们先把后端代码写出来：
在
None
在
None
管理页面：
None
模板页面首先通过API：
None
然后，通过Vue初始化MVVM：
None
View的容器是
None
往Model的
可以把
完整的Blog列表页如下：
None
参考源码
None
<br><br><br>Day 13 - 提升开发效率<br>============
现在，我们已经把一个Web App的框架完全搭建好了，从后端的API到前端的MVVM，流程已经跑通了。
在继续工作前，注意到每次修改Python代码，都必须在命令行先Ctrl-C停止服务器，再重启，改动才能生效。
在开发阶段，每天都要修改、保存几十次代码，每次保存都手动来这么一下非常麻烦，严重地降低了我们的开发效率。有没有办法让服务器检测到代码修改后自动重新加载呢？
Django的开发环境在Debug模式下就可以做到自动重新加载，如果我们编写的服务器也能实现这个功能，就能大大提升开发效率。
可惜的是，Django没把这个功能独立出来，不用Django就享受不到，怎么办？
其实Python本身提供了重新载入模块的功能，但不是所有模块都能被重新载入。另一种思路是检测
按照这个思路，我们可以编写一个辅助程序
要监控目录文件的变化，我们也无需自己手动定时扫描，Python的第三方库
None
利用
利用Python自带的
None
一共70行左右的代码，就实现了Debug模式的自动重新加载。用下面的命令启动服务器：
None
或者给
None
在编辑器中打开一个
None
现在，只要一保存代码，就可以刷新浏览器看到效果，大大提升了开发效率。
<br><br><br>Day 14 - 完成Web App<br>============
在Web App框架和基本流程跑通后，剩下的工作全部是体力活了：在Debug开发模式下完成后端所有API、前端所有页面。我们需要做的事情包括：
把当前用户绑定到
None
后端API包括：


管理页面包括：


用户浏览页面包括：


把所有的功能实现，我们第一个Web App就宣告完成！
参考源码
None
<br><br><br>Day 15 - 部署Web App<br>============
作为一个合格的开发者，在本地环境下完成开发还远远不够，我们需要把Web App部署到远程服务器上，这样，广大用户才能访问到网站。
很多做开发的同学把部署这件事情看成是运维同学的工作，这种看法是完全错误的。首先，最近流行
下面，我们就来把awesome-python3-webapp部署到Linux服务器。
搭建Linux服务器
要部署到Linux，首先得有一台Linux服务器。要在公网上体验的同学，可以在Amazon的
我们选择的Linux服务器版本是
Linux安装完成后，请确保ssh服务正在运行，否则，需要通过apt安装：
None
有了ssh服务，就可以从本地连接到服务器上。建议把公钥复制到服务器端用户的
部署方式
利用Python自带的asyncio，我们已经编写了一个异步高性能服务器。但是，我们还需要一个高性能的Web服务器，这里选择Nginx，它可以处理静态资源，同时作为反向代理把动态请求交给Python代码处理。这个模型如下：
None
Nginx负责分发请求：
None
在服务器端，我们需要定义好部署的目录结构：
None
在服务器上部署，要考虑到新版本如果运行不正常，需要回退到旧版本时怎么办。每次用新的代码覆盖掉旧的文件是不行的，需要一个类似版本控制的机制。由于Linux系统提供了软链接功能，所以，我们把
None
而Nginx和python代码的配置文件只需要指向
Nginx可以作为服务进程直接启动，但
总结一下我们需要用到的服务有：


在Linux服务器上用apt可以直接安装上述服务：
None
然后，再把我们自己的Web App用到的Python库安装了：
None
在服务器上创建目录
在服务器上初始化MySQL数据库，把数据库初始化脚本
None
服务器端准备就绪。
部署
用FTP还是SCP还是rsync复制文件？如果你需要手动复制，用一次两次还行，一天如果部署50次不但慢、效率低，而且容易出错。
正确的部署方式是使用工具配合脚本完成自动化部署。
要用Fabric部署，需要在本机（是开发机器，不是Linux服务器）安装Fabric：
None
Linux服务器上不需要安装Fabric，Fabric使用SSH直接登录服务器并执行部署命令。
下一步是编写部署脚本。Fabric的部署脚本叫
None
Fabric的脚本编写很简单，首先导入Fabric的API，设置部署时的变量：
None
然后，每个Python函数都是一个任务。我们先编写一个打包的任务：
None
Fabric提供
在
None
看看是否在
打包后，我们就可以继续编写
None
注意
配置Supervisor
上面让Supervisor重启awesome的命令会失败，因为我们还没有配置Supervisor呢。
编写一个Supervisor的配置文件
None
配置文件通过
然后重启Supervisor后，就可以随时启动和停止Supervisor管理的服务了：
None
配置Nginx
Supervisor只负责运行
None
然后在
None
让Nginx重新加载配置文件，不出意外，我们的
None
如果有任何错误，都可以在
如果一切顺利，你可以在浏览器中访问Linux服务器上的
None
如果在开发环境更新了代码，只需要在命令行执行：
None
自动部署完成！刷新浏览器就可以看到服务器代码更新后的效果。
友情链接
嫌国外网速慢的童鞋请移步网易和搜狐的镜像站点：
None
None
参考源码
None
<br><br><br>Day 16 - 编写移动App<br>============
网站部署上线后，还缺点啥呢？
在移动互联网浪潮席卷而来的今天，一个网站没有上线移动App，出门根本不好意思跟人打招呼。
所以，
开发iPhone版本
我们首先来看看如何开发iPhone App。前置条件：一台Mac电脑，安装XCode和最新的iOS SDK。
在使用MVVM编写前端页面时，我们就能感受到，用REST API封装网站后台的功能，不但能清晰地分离前端页面和后台逻辑，现在这个好处更加明显，移动App也可以通过REST API从后端拿到数据。
我们来设计一个简化版的iPhone App，包含两个屏幕：列出最新日志和阅读日志的详细内容：
None
只需要调用API：
在XCode中完成App编写：
None
由于我们的教程是Python，关于如何开发iOS，请移步
None
如何编写Android App？这个当成作业了。
参考源码
None
<br><br><br>FAQ<br>============
常见问题
本节列出常见的一些问题。
如何获取当前路径
当前路径可以用
None
运行结果：
None
如何获取当前模块的文件名
可以通过特殊变量
None
输出：
None
如何获取命令行参数
可以通过
None
输出：
None
None
如何获取当前Python命令的可执行文件路径
None
None
在Mac下的结果：
None
<br><br><br>期末总结<br>============
终于到了期末总结的时刻了！
经过一段时间的学习，相信你对Python已经初步掌握。一开始，可能觉得Python上手很容易，可是越往后学，会越困难，有的时候，发现理解不了代码，这时，不妨停下来思考一下，先把概念搞清楚，代码自然就明白了。
Python非常适合初学者用来进入计算机编程领域。Python属于非常高级的语言，掌握了这门高级语言，就对计算机编程的核心思想——抽象有了初步理解。如果希望继续深入学习计算机编程，可以学习Java、C、JavaScript、Lisp等不同类型的语言，只有多掌握不同领域的语言，有比较才更有收获。
None
